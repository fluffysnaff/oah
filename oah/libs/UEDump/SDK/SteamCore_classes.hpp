#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SteamCore

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "SteamCore_structs.hpp"


namespace SDK
{

// Class SteamCore.SteamCoreAsyncAction
// 0x0008 (0x0038 - 0x0030)
class USteamCoreAsyncAction : public UBlueprintAsyncActionBase
{
public:
	TWeakObjectPtr<class UObject>                 M_WorldContextObject;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreAsyncAction">();
	}
	static class USteamCoreAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreAsyncAction>();
	}
};
static_assert(alignof(USteamCoreAsyncAction) == 0x000008, "Wrong alignment on USteamCoreAsyncAction");
static_assert(sizeof(USteamCoreAsyncAction) == 0x000038, "Wrong size on USteamCoreAsyncAction");
static_assert(offsetof(USteamCoreAsyncAction, M_WorldContextObject) == 0x000030, "Member 'USteamCoreAsyncAction::M_WorldContextObject' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionGetUserItemVote
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionGetUserItemVote final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionGetUserItemVote* GetUserItemVoteAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FGetUserItemVoteResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionGetUserItemVote">();
	}
	static class USteamCoreUGCAsyncActionGetUserItemVote* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionGetUserItemVote>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionGetUserItemVote) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionGetUserItemVote");
static_assert(sizeof(USteamCoreUGCAsyncActionGetUserItemVote) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionGetUserItemVote");
static_assert(offsetof(USteamCoreUGCAsyncActionGetUserItemVote, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionGetUserItemVote::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreSubsystem
// 0x0038 (0x0068 - 0x0030)
class USteamCoreSubsystem : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreSubsystem">();
	}
	static class USteamCoreSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreSubsystem>();
	}
};
static_assert(alignof(USteamCoreSubsystem) == 0x000008, "Wrong alignment on USteamCoreSubsystem");
static_assert(sizeof(USteamCoreSubsystem) == 0x000068, "Wrong size on USteamCoreSubsystem");

// Class SteamCore.SteamCoreUGCAsyncActionSetUserItemVote
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionSetUserItemVote final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionSetUserItemVote* SetUserItemVoteAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, bool bVoteUp, float Timeout);

	void HandleCallback(const struct FSetUserItemVoteResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionSetUserItemVote">();
	}
	static class USteamCoreUGCAsyncActionSetUserItemVote* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionSetUserItemVote>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionSetUserItemVote) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionSetUserItemVote");
static_assert(sizeof(USteamCoreUGCAsyncActionSetUserItemVote) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionSetUserItemVote");
static_assert(offsetof(USteamCoreUGCAsyncActionSetUserItemVote, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionSetUserItemVote::OnCallback' has a wrong offset!");

// Class SteamCore.AppList
// 0x0060 (0x00C8 - 0x0068)
class UAppList final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             SteamAppInstalled;                                 // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamAppUninstalled;                               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAppBuildId(int32 AppID);
	int32 GetAppInstallDir(int32 AppID, class FString* Directory);
	int32 GetAppName(int32 AppID, class FString* Name_0);
	int32 GetInstalledApps(TArray<int32>* AppIDs, int32 MaxAppIDs);
	int32 GetNumInstalledApps();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppList">();
	}
	static class UAppList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppList>();
	}
};
static_assert(alignof(UAppList) == 0x000008, "Wrong alignment on UAppList");
static_assert(sizeof(UAppList) == 0x0000C8, "Wrong size on UAppList");
static_assert(offsetof(UAppList, SteamAppInstalled) == 0x000068, "Member 'UAppList::SteamAppInstalled' has a wrong offset!");
static_assert(offsetof(UAppList, SteamAppUninstalled) == 0x000078, "Member 'UAppList::SteamAppUninstalled' has a wrong offset!");

// Class SteamCore.SteamCoreGameMode
// 0x0000 (0x0308 - 0x0308)
class ASteamCoreGameMode final : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreGameMode">();
	}
	static class ASteamCoreGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteamCoreGameMode>();
	}
};
static_assert(alignof(ASteamCoreGameMode) == 0x000008, "Wrong alignment on ASteamCoreGameMode");
static_assert(sizeof(ASteamCoreGameMode) == 0x000308, "Wrong size on ASteamCoreGameMode");

// Class SteamCore.SteamCoreUGCAsyncActionSubmitItemUpdate
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionSubmitItemUpdate final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionSubmitItemUpdate* SubmitItemUpdateAsync(class UObject* WorldContextObject, const struct FUGCUpdateHandle& Handle, const class FString& ChangeNote, float Timeout);

	void HandleCallback(const struct FSubmitItemUpdateResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionSubmitItemUpdate">();
	}
	static class USteamCoreUGCAsyncActionSubmitItemUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionSubmitItemUpdate>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionSubmitItemUpdate) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionSubmitItemUpdate");
static_assert(sizeof(USteamCoreUGCAsyncActionSubmitItemUpdate) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionSubmitItemUpdate");
static_assert(offsetof(USteamCoreUGCAsyncActionSubmitItemUpdate, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionSubmitItemUpdate::OnCallback' has a wrong offset!");

// Class SteamCore.Apps
// 0x0060 (0x00C8 - 0x0068)
class UApps final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             DLCInstalled;                                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FileDetailsResultDelegate;                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BGetDLCDataByIndex(int32 DLC, int32* AppID, bool* bAvailable, class FString* Name_0);
	static bool BIsAppInstalled(int32 AppID);
	static bool BIsCybercafe();
	static bool BIsDlcInstalled(int32 AppID);
	static bool BIsLowViolence();
	static bool BIsSubscribed();
	static bool BIsSubscribedApp(int32 AppID);
	static bool BIsSubscribedFromFamilySharing();
	static bool BIsSubscribedFromFreeWeekend();
	static bool BIsTimedTrial(int32* SecondsAllowed, int32* SecondsPlayed);
	static bool BIsVACBanned();
	static int32 GetAppBuildId();
	static int32 GetAppInstallDir(int32 AppID, class FString* Folder);
	static struct FSteamID GetAppOwner();
	static class FString GetAvailableGameLanguages();
	static bool GetCurrentBetaName(class FString* Name_0);
	static class FString GetCurrentGameLanguage();
	static int32 GetDLCCount();
	static bool GetDlcDownloadProgress(int32 AppID, int32* BytesDownloaded, int32* BytesTotal);
	static int32 GetEarliestPurchaseUnixTime(int32 AppID);
	static int32 GetInstalledDepots(int32 AppID, int32 MaxDepots, TArray<int32>* Depots);
	static int32 GetLaunchCommandLine(class FString* CommandLine);
	static class FString GetLaunchQueryParam(const class FString& Key);
	static void InstallDLC(int32 AppID);
	static bool MarkContentCorrupt(bool bMissingFilesOnly);
	static void UninstallDLC(int32 AppID);

	void GetFileDetails(const TDelegate<void(struct FFileDetailsResult& Data, bool bWasSuccessful)>& Callback, const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Apps">();
	}
	static class UApps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApps>();
	}
};
static_assert(alignof(UApps) == 0x000008, "Wrong alignment on UApps");
static_assert(sizeof(UApps) == 0x0000C8, "Wrong size on UApps");
static_assert(offsetof(UApps, DLCInstalled) == 0x000068, "Member 'UApps::DLCInstalled' has a wrong offset!");
static_assert(offsetof(UApps, FileDetailsResultDelegate) == 0x000078, "Member 'UApps::FileDetailsResultDelegate' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionSendQueryUGCRequest
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionSendQueryUGCRequest final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionSendQueryUGCRequest* SendQueryUGCRequestAsync(class UObject* WorldContextObject, const struct FUGCQueryHandle& Handle, float Timeout);

	void HandleCallback(const struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionSendQueryUGCRequest">();
	}
	static class USteamCoreUGCAsyncActionSendQueryUGCRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionSendQueryUGCRequest>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionSendQueryUGCRequest) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionSendQueryUGCRequest");
static_assert(sizeof(USteamCoreUGCAsyncActionSendQueryUGCRequest) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionSendQueryUGCRequest");
static_assert(offsetof(USteamCoreUGCAsyncActionSendQueryUGCRequest, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionSendQueryUGCRequest::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionAddAppDependency
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionAddAppDependency final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionAddAppDependency* AddAppDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, int32 AppID, float Timeout);

	void HandleCallback(const struct FAddAppDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionAddAppDependency">();
	}
	static class USteamCoreUGCAsyncActionAddAppDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionAddAppDependency>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionAddAppDependency) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionAddAppDependency");
static_assert(sizeof(USteamCoreUGCAsyncActionAddAppDependency) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionAddAppDependency");
static_assert(offsetof(USteamCoreUGCAsyncActionAddAppDependency, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionAddAppDependency::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreAppsAsyncActionGetFileDetails
// 0x0010 (0x0048 - 0x0038)
class USteamCoreAppsAsyncActionGetFileDetails final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreAppsAsyncActionGetFileDetails* GetFileDetailsAsync(class UObject* WorldContextObject, const class FString& Filename, float Timeout);

	void HandleCallback(const struct FFileDetailsResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreAppsAsyncActionGetFileDetails">();
	}
	static class USteamCoreAppsAsyncActionGetFileDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreAppsAsyncActionGetFileDetails>();
	}
};
static_assert(alignof(USteamCoreAppsAsyncActionGetFileDetails) == 0x000008, "Wrong alignment on USteamCoreAppsAsyncActionGetFileDetails");
static_assert(sizeof(USteamCoreAppsAsyncActionGetFileDetails) == 0x000048, "Wrong size on USteamCoreAppsAsyncActionGetFileDetails");
static_assert(offsetof(USteamCoreAppsAsyncActionGetFileDetails, OnCallback) == 0x000038, "Member 'USteamCoreAppsAsyncActionGetFileDetails::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCore
// 0x0000 (0x0028 - 0x0028)
class USteamCore final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCore">();
	}
	static class USteamCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCore>();
	}
};
static_assert(alignof(USteamCore) == 0x000008, "Wrong alignment on USteamCore");
static_assert(sizeof(USteamCore) == 0x000028, "Wrong size on USteamCore");

// Class SteamCore.SteamCoreSettings
// 0x0028 (0x0060 - 0x0038)
class USteamCoreSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnabled;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelaunchInSteam;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVACEnabled;                                       // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowP2PPacketRelay;                              // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P2PConnectionTimeout;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SteamAppId;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SteamDevAppId;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameServerQueryPort;                               // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameVersion;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreSettings">();
	}
	static class USteamCoreSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreSettings>();
	}
};
static_assert(alignof(USteamCoreSettings) == 0x000008, "Wrong alignment on USteamCoreSettings");
static_assert(sizeof(USteamCoreSettings) == 0x000060, "Wrong size on USteamCoreSettings");
static_assert(offsetof(USteamCoreSettings, bEnabled) == 0x000038, "Member 'USteamCoreSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, bRelaunchInSteam) == 0x000039, "Member 'USteamCoreSettings::bRelaunchInSteam' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, bVACEnabled) == 0x00003A, "Member 'USteamCoreSettings::bVACEnabled' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, bAllowP2PPacketRelay) == 0x00003B, "Member 'USteamCoreSettings::bAllowP2PPacketRelay' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, P2PConnectionTimeout) == 0x00003C, "Member 'USteamCoreSettings::P2PConnectionTimeout' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, SteamAppId) == 0x000040, "Member 'USteamCoreSettings::SteamAppId' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, SteamDevAppId) == 0x000044, "Member 'USteamCoreSettings::SteamDevAppId' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, Port) == 0x000048, "Member 'USteamCoreSettings::Port' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, GameServerQueryPort) == 0x00004C, "Member 'USteamCoreSettings::GameServerQueryPort' has a wrong offset!");
static_assert(offsetof(USteamCoreSettings, GameVersion) == 0x000050, "Member 'USteamCoreSettings::GameVersion' has a wrong offset!");

// Class SteamCore.Friends
// 0x02D0 (0x0338 - 0x0068)
class UFriends final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             AvatarImageLoaded;                                 // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FriendRichPresenceUpdate;                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedChatJoin;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedChatLeave;                            // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedClanChatMsg;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameConnectedFriendChatMsg;                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameLobbyJoinRequested;                            // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameOverlayActivated;                              // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameRichPresenceJoinRequested;                     // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameServerChangeRequested;                         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             PersonaStateChange;                                // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SetPersonaNameResponse;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             JoinClanChatRoomCompletionResult;                  // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ClanOfficerListResponse;                           // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DownloadClanActivityCountsResult;                  // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x1E0];                                    // 0x0158(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ActivateGameOverlay(const class FString& Dialog);
	static void ActivateGameOverlayInvitedialog(const struct FSteamID& SteamIDLobby);
	static void ActivateGameOverlayInviteDialogConnectString(const class FString& ConnectString);
	static void ActivateGameOverlayToStore(int32 AppID, ESteamOverlayToStoreFlag Flag);
	static void ActivateGameOverlayToUser(const class FString& Dialog, const struct FSteamID& SteamID);
	static void ActivateGameOverlayToWebPage(const class FString& URL, ESteamActivateGameOverlayToWebPageMode Mode);
	static void ClearRichPresence();
	static bool CloseClanChatWindowInSteam(const struct FSteamID& SteamIDClanChat);
	static struct FSteamID GetChatMemberByIndex(const struct FSteamID& SteamIDClan, int32 User);
	static bool GetClanActivityCounts(const struct FSteamID& SteamIDClan, int32* Online, int32* InGame, int32* Chatting);
	static struct FSteamID GetClanByIndex(int32 Clan);
	static int32 GetClanChatMemberCount(const struct FSteamID& SteamIDClan);
	static int32 GetClanChatMessage(const struct FSteamID& SteamIDClanChat, int32 MessageID, class FString* Text, ESteamChatEntryType* ChatEntryType, struct FSteamID* SteamIDChatter);
	static int32 GetClanCount();
	static class FString GetClanName(const struct FSteamID& SteamIDClan);
	static struct FSteamID GetClanOfficerByIndex(const struct FSteamID& SteamIDClan, int32 Officer);
	static int32 GetClanOfficerCount(const struct FSteamID& SteamIDClan);
	static struct FSteamID GetClanOwner(const struct FSteamID& SteamIDClan);
	static class FString GetClanTag(const struct FSteamID& SteamIDClan);
	static struct FSteamID GetCoplayFriend(int32 CoplayFriend);
	static int32 GetCoplayFriendCount();
	static struct FSteamID GetFriendByIndex(int32 Ifriend, const TArray<ESteamFriendFlags>& Flags_0);
	static int32 GetFriendCoplayGame(const struct FSteamID& SteamIDFriend);
	static int32 GetFriendCoplayTime(const struct FSteamID& SteamIDFriend);
	static int32 GetFriendCount(const TArray<ESteamFriendFlags>& Flags_0);
	static int32 GetFriendCountFromSource(const struct FSteamID& SteamIDSource);
	static struct FSteamID GetFriendFromSourceByIndex(const struct FSteamID& SteamIDSource, int32 Ifriend);
	static bool GetFriendGamePlayed(const struct FSteamID& SteamIDFriend, struct FSteamGameID* GameID, class FString* GameIP, int32* ConnectionPort, int32* QueryPort, struct FSteamID* SteamIDLobby);
	static int32 GetFriendMessage(const struct FSteamID& SteamIDFriend, int32 MessageID, class FString* Text, ESteamChatEntryType* ChatEntryType);
	static class FString GetFriendPersonaName(const struct FSteamID& SteamIDFriend);
	static class FString GetFriendPersonaNameHistory(const struct FSteamID& SteamIDFriend, int32 PersonaName);
	static ESteamPersonaState GetFriendPersonaState(const struct FSteamID& SteamIDFriend);
	static ESteamFriendRelationship GetFriendRelationship(const struct FSteamID& SteamIDFriend);
	static class FString GetFriendRichPresence(const struct FSteamID& SteamIDFriend, const class FString& Key);
	static class FString GetFriendRichPresenceKeyByIndex(const struct FSteamID& SteamIDFriend, int32 Key);
	static int32 GetFriendRichPresenceKeyCount(const struct FSteamID& SteamIDFriend);
	static int32 GetFriendsGroupCount();
	static struct FSteamFriendsGroupID GetFriendsGroupIDByIndex(int32 FriendGroup);
	static int32 GetFriendsGroupMembersCount(const struct FSteamFriendsGroupID& FriendsGroupID);
	static void GetFriendsGroupMembersList(const struct FSteamFriendsGroupID& FriendsGroupID, TArray<struct FSteamID>* SteamIDMembers, int32 MembersCount);
	static class FString GetFriendsGroupName(const struct FSteamFriendsGroupID& FriendsGroupID);
	static int32 GetFriendSteamLevel(const struct FSteamID& SteamIDFriend);
	static class UTexture2D* GetLargeFriendAvatar(const struct FSteamID& SteamIDFriend);
	static class UTexture2D* GetMediumFriendAvatar(const struct FSteamID& SteamIDFriend);
	static class FString GetPersonaName();
	static class FString GetPersonaName_Pure();
	static ESteamPersonaState GetPersonaState();
	static ESteamPersonaState GetPersonaState_Pure();
	static class FString GetPlayerNickname(const struct FSteamID& SteamIDPlayer);
	static class FString GetPlayerNickname_Pure(const struct FSteamID& SteamIDPlayer);
	static class UTexture2D* GetSmallFriendAvatar(const struct FSteamID& SteamIDFriend);
	static TArray<ESteamUserRestriction> GetUserRestrictions();
	static bool HasFriend(const struct FSteamID& SteamIDFriend, const TArray<ESteamFriendFlags>& Flags_0);
	static bool InviteUserToGame(const struct FSteamID& SteamIDFriend, const class FString& ConnectString);
	static bool IsClanChatAdmin(const struct FSteamID& SteamIDClanChat, const struct FSteamID& SteamIDUser);
	static bool IsClanChatWindowOpenInSteam(const struct FSteamID& SteamIDClanChat);
	static bool IsClanOfficialGameGroup(const struct FSteamID& SteamIDClan);
	static bool IsClanPublic(const struct FSteamID& SteamIDClan);
	static bool IsUserInSource(const struct FSteamID& SteamIDUser, const struct FSteamID& SteamIDSource);
	static bool LeaveClanChatRoom(const struct FSteamID& SteamIDClan);
	static bool OpenClanChatWindowInSteam(const struct FSteamID& SteamIDClanChat);
	static bool RegisterProtocolInOverlayBrowser(const class FString& Protocol);
	static bool ReplyToFriendMessage(const struct FSteamID& SteamIDFriend, const class FString& MsgToSend);
	static void RequestFriendRichPresence(const struct FSteamID& SteamIDFriend);
	static bool RequestUserInformation(const struct FSteamID& SteamIDUser, bool bRequireNameOnly);
	static bool SendClanChatMessage(const struct FSteamID& SteamIDClanChat, const class FString& Text);
	static void SetInGameVoiceSpeaking(const struct FSteamID& SteamIDUser, bool bSpeaking);
	static bool SetListenForFriendsMessages(bool bInterceptEnabled);
	static void SetPlayedWith(const struct FSteamID& SteamIDUserPlayedWith);
	static bool SetRichPresence(const class FString& Key, const class FString& Value);

	void DownloadClanActivityCounts(const TDelegate<void(struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FSteamID>& SteamIDClans);
	void EnumerateFollowingList(const TDelegate<void(struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful)>& Callback, int32 StartIndex);
	void GetFollowerCount(const TDelegate<void(struct FFriendsGetFollowerCount& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void IsFollowing(const TDelegate<void(struct FFriendsIsFollowing& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void JoinClanChatRoom(const TDelegate<void(struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan);
	void RequestClanOfficerList(const TDelegate<void(struct FClanOfficerListResponse& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan);
	void SetPersonaName(const TDelegate<void(struct FSetPersonaNameResponse& Data, bool bWasSuccessful)>& Callback, const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Friends">();
	}
	static class UFriends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriends>();
	}
};
static_assert(alignof(UFriends) == 0x000008, "Wrong alignment on UFriends");
static_assert(sizeof(UFriends) == 0x000338, "Wrong size on UFriends");
static_assert(offsetof(UFriends, AvatarImageLoaded) == 0x000068, "Member 'UFriends::AvatarImageLoaded' has a wrong offset!");
static_assert(offsetof(UFriends, FriendRichPresenceUpdate) == 0x000078, "Member 'UFriends::FriendRichPresenceUpdate' has a wrong offset!");
static_assert(offsetof(UFriends, GameConnectedChatJoin) == 0x000088, "Member 'UFriends::GameConnectedChatJoin' has a wrong offset!");
static_assert(offsetof(UFriends, GameConnectedChatLeave) == 0x000098, "Member 'UFriends::GameConnectedChatLeave' has a wrong offset!");
static_assert(offsetof(UFriends, GameConnectedClanChatMsg) == 0x0000A8, "Member 'UFriends::GameConnectedClanChatMsg' has a wrong offset!");
static_assert(offsetof(UFriends, GameConnectedFriendChatMsg) == 0x0000B8, "Member 'UFriends::GameConnectedFriendChatMsg' has a wrong offset!");
static_assert(offsetof(UFriends, GameLobbyJoinRequested) == 0x0000C8, "Member 'UFriends::GameLobbyJoinRequested' has a wrong offset!");
static_assert(offsetof(UFriends, GameOverlayActivated) == 0x0000D8, "Member 'UFriends::GameOverlayActivated' has a wrong offset!");
static_assert(offsetof(UFriends, GameRichPresenceJoinRequested) == 0x0000E8, "Member 'UFriends::GameRichPresenceJoinRequested' has a wrong offset!");
static_assert(offsetof(UFriends, GameServerChangeRequested) == 0x0000F8, "Member 'UFriends::GameServerChangeRequested' has a wrong offset!");
static_assert(offsetof(UFriends, PersonaStateChange) == 0x000108, "Member 'UFriends::PersonaStateChange' has a wrong offset!");
static_assert(offsetof(UFriends, SetPersonaNameResponse) == 0x000118, "Member 'UFriends::SetPersonaNameResponse' has a wrong offset!");
static_assert(offsetof(UFriends, JoinClanChatRoomCompletionResult) == 0x000128, "Member 'UFriends::JoinClanChatRoomCompletionResult' has a wrong offset!");
static_assert(offsetof(UFriends, ClanOfficerListResponse) == 0x000138, "Member 'UFriends::ClanOfficerListResponse' has a wrong offset!");
static_assert(offsetof(UFriends, DownloadClanActivityCountsResult) == 0x000148, "Member 'UFriends::DownloadClanActivityCountsResult' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionSetPersonaName
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionSetPersonaName final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionSetPersonaName* SetPersonaNameAsync(class UObject* WorldContextObject, const class FString& Name_0, float Timeout);

	void HandleCallback(const struct FSetPersonaNameResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionSetPersonaName">();
	}
	static class USteamCoreFriendsAsyncActionSetPersonaName* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionSetPersonaName>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionSetPersonaName) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionSetPersonaName");
static_assert(sizeof(USteamCoreFriendsAsyncActionSetPersonaName) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionSetPersonaName");
static_assert(offsetof(USteamCoreFriendsAsyncActionSetPersonaName, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionSetPersonaName::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionDownloadClanActivityCounts
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionDownloadClanActivityCounts final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionDownloadClanActivityCounts* DownloadClanActivityCountsAsync(class UObject* WorldContextObject, const TArray<struct FSteamID>& SteamIDClans, float Timeout);

	void HandleCallback(const struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionDownloadClanActivityCounts">();
	}
	static class USteamCoreFriendsAsyncActionDownloadClanActivityCounts* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionDownloadClanActivityCounts>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionDownloadClanActivityCounts) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionDownloadClanActivityCounts");
static_assert(sizeof(USteamCoreFriendsAsyncActionDownloadClanActivityCounts) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionDownloadClanActivityCounts");
static_assert(offsetof(USteamCoreFriendsAsyncActionDownloadClanActivityCounts, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionDownloadClanActivityCounts::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionRequestClanOfficerList
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionRequestClanOfficerList final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionRequestClanOfficerList* RequestClanOfficerListAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDClan, float Timeout);

	void HandleCallback(const struct FClanOfficerListResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionRequestClanOfficerList">();
	}
	static class USteamCoreFriendsAsyncActionRequestClanOfficerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionRequestClanOfficerList>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionRequestClanOfficerList) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionRequestClanOfficerList");
static_assert(sizeof(USteamCoreFriendsAsyncActionRequestClanOfficerList) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionRequestClanOfficerList");
static_assert(offsetof(USteamCoreFriendsAsyncActionRequestClanOfficerList, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionRequestClanOfficerList::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionJoinClanChatRoom
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionJoinClanChatRoom final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionJoinClanChatRoom* JoinClanChatRoomAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDClan, float Timeout);

	void HandleCallback(const struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionJoinClanChatRoom">();
	}
	static class USteamCoreFriendsAsyncActionJoinClanChatRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionJoinClanChatRoom>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionJoinClanChatRoom) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionJoinClanChatRoom");
static_assert(sizeof(USteamCoreFriendsAsyncActionJoinClanChatRoom) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionJoinClanChatRoom");
static_assert(offsetof(USteamCoreFriendsAsyncActionJoinClanChatRoom, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionJoinClanChatRoom::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionEnumerateFollowingList
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionEnumerateFollowingList final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionEnumerateFollowingList* EnumerateFollowingListAsync(class UObject* WorldContextObject, int32 StartIndex, float Timeout);

	void HandleCallback(const struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionEnumerateFollowingList">();
	}
	static class USteamCoreFriendsAsyncActionEnumerateFollowingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionEnumerateFollowingList>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionEnumerateFollowingList) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionEnumerateFollowingList");
static_assert(sizeof(USteamCoreFriendsAsyncActionEnumerateFollowingList) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionEnumerateFollowingList");
static_assert(offsetof(USteamCoreFriendsAsyncActionEnumerateFollowingList, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionEnumerateFollowingList::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionIsFollowing
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionIsFollowing final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionIsFollowing* IsFollowingAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FFriendsIsFollowing& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionIsFollowing">();
	}
	static class USteamCoreFriendsAsyncActionIsFollowing* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionIsFollowing>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionIsFollowing) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionIsFollowing");
static_assert(sizeof(USteamCoreFriendsAsyncActionIsFollowing) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionIsFollowing");
static_assert(offsetof(USteamCoreFriendsAsyncActionIsFollowing, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionIsFollowing::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionGetFollowerCount
// 0x0010 (0x0048 - 0x0038)
class USteamCoreFriendsAsyncActionGetFollowerCount final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreFriendsAsyncActionGetFollowerCount* GetFollowerCountAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FFriendsGetFollowerCount& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionGetFollowerCount">();
	}
	static class USteamCoreFriendsAsyncActionGetFollowerCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionGetFollowerCount>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionGetFollowerCount) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionGetFollowerCount");
static_assert(sizeof(USteamCoreFriendsAsyncActionGetFollowerCount) == 0x000048, "Wrong size on USteamCoreFriendsAsyncActionGetFollowerCount");
static_assert(offsetof(USteamCoreFriendsAsyncActionGetFollowerCount, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionGetFollowerCount::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreFriendsAsyncActionRequestUserInformation
// 0x0040 (0x0078 - 0x0038)
class USteamCoreFriendsAsyncActionRequestUserInformation final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreFriendsAsyncActionRequestUserInformation* RequestUserInformationAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDUser, bool bRequireNameOnly, float Timeout);

	void HandleCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFriendsAsyncActionRequestUserInformation">();
	}
	static class USteamCoreFriendsAsyncActionRequestUserInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFriendsAsyncActionRequestUserInformation>();
	}
};
static_assert(alignof(USteamCoreFriendsAsyncActionRequestUserInformation) == 0x000008, "Wrong alignment on USteamCoreFriendsAsyncActionRequestUserInformation");
static_assert(sizeof(USteamCoreFriendsAsyncActionRequestUserInformation) == 0x000078, "Wrong size on USteamCoreFriendsAsyncActionRequestUserInformation");
static_assert(offsetof(USteamCoreFriendsAsyncActionRequestUserInformation, OnCallback) == 0x000038, "Member 'USteamCoreFriendsAsyncActionRequestUserInformation::OnCallback' has a wrong offset!");

// Class SteamCore.SteamGameSearch
// 0x0150 (0x01B8 - 0x0068)
class USteamGameSearch final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             SearchForGameProgressDelegate;                     // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SearchForGameResultDelegate;                       // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RequestPlayersForGameProgressDelegate;             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RequestPlayersForGameResultDelegate;               // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RequestPlayersForGameFinalResultDelegate;          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SubmitPlayerResultResultDelegate;                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EndGameResultDelegate;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xE0];                                      // 0x00D8(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESteamGameSearchErrorCode AcceptGame();
	ESteamGameSearchErrorCode AddGameSearchParams(const class FString& KeyToFind, const TArray<class FString>& ValuesToFind);
	ESteamGameSearchErrorCode CancelRequestPlayersForGame();
	ESteamGameSearchErrorCode DeclineGame();
	ESteamGameSearchErrorCode EndGame(const class FString& UniqueGameID);
	ESteamGameSearchErrorCode EndGameSearch();
	ESteamGameSearchErrorCode HostConfirmGameStart(const class FString& UniqueGameID);
	ESteamGameSearchErrorCode RequestPlayersForGame(int32 PlayerMin, int32 PlayerMax, int32 MaxTeamSize);
	ESteamGameSearchErrorCode RetrieveConnectionDetails(const struct FSteamID& SteamIDHost, class FString* ConnectionDetails, int32 NumConnectionDetails);
	ESteamGameSearchErrorCode SearchForGameSolo(int32 PlayerMin, int32 PlayerMax);
	ESteamGameSearchErrorCode SearchForGameWithLobby(const struct FSteamID& SteamIDLobby, int32 PlayerMin, int32 PlayerMax);
	ESteamGameSearchErrorCode SetConnectionDetails(const class FString& ConnectionDetails);
	ESteamGameSearchErrorCode SetGameHostParams(const class FString& Key, const TArray<class FString>& Values);
	ESteamGameSearchErrorCode SubmitPlayerResult(const class FString& UniqueGameID, const struct FSteamID& SteamIDPlayer, ESteamPlayerResult PlayerResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamGameSearch">();
	}
	static class USteamGameSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamGameSearch>();
	}
};
static_assert(alignof(USteamGameSearch) == 0x000008, "Wrong alignment on USteamGameSearch");
static_assert(sizeof(USteamGameSearch) == 0x0001B8, "Wrong size on USteamGameSearch");
static_assert(offsetof(USteamGameSearch, SearchForGameProgressDelegate) == 0x000068, "Member 'USteamGameSearch::SearchForGameProgressDelegate' has a wrong offset!");
static_assert(offsetof(USteamGameSearch, SearchForGameResultDelegate) == 0x000078, "Member 'USteamGameSearch::SearchForGameResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamGameSearch, RequestPlayersForGameProgressDelegate) == 0x000088, "Member 'USteamGameSearch::RequestPlayersForGameProgressDelegate' has a wrong offset!");
static_assert(offsetof(USteamGameSearch, RequestPlayersForGameResultDelegate) == 0x000098, "Member 'USteamGameSearch::RequestPlayersForGameResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamGameSearch, RequestPlayersForGameFinalResultDelegate) == 0x0000A8, "Member 'USteamGameSearch::RequestPlayersForGameFinalResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamGameSearch, SubmitPlayerResultResultDelegate) == 0x0000B8, "Member 'USteamGameSearch::SubmitPlayerResultResultDelegate' has a wrong offset!");
static_assert(offsetof(USteamGameSearch, EndGameResultDelegate) == 0x0000C8, "Member 'USteamGameSearch::EndGameResultDelegate' has a wrong offset!");

// Class SteamCore.SteamGameServer
// 0x00F0 (0x0158 - 0x0068)
class USteamGameServer final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             GSPolicyResponse;                                  // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSClientGroupStatus;                               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSValidateAuthTicketResponse;                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSClientApprove;                                   // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GSClientDeny;                                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0xA0];                                      // 0x00B8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssociateWithClan(const TDelegate<void(struct FAssociateWithClanResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan);
	ESteamBeginAuthSessionResult BeginAuthSession(const TArray<uint8>& Ticket, const struct FSteamID& SteamID);
	bool BLoggedOn();
	bool BSecure();
	bool BUpdateUserData(const struct FSteamID& SteamIDUser, const class FString& PlayerName, int32 Score);
	void CancelAuthTicket(const struct FSteamTicketHandle& TicketHandle);
	void ClearAllKeyValues();
	void ComputeNewPlayerCompatibility(const TDelegate<void(struct FComputeNewPlayerCompatibilityResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDNewPlayer);
	struct FSteamID CreateUnauthenticatedUserConnection();
	void EnableHeartbeats(bool bActive);
	void EndAuthSession(const struct FSteamID& SteamID);
	void ForceHeartbeat();
	struct FSteamTicketHandle GetAuthSessionTicket(TArray<uint8>* Ticket);
	class FString GetServerPublicIP();
	class FString GetServerPublicIP_Pure();
	class FString GetServerPublicIP_PureCompact();
	struct FSteamID GetServerSteamID();
	struct FSteamID GetServerSteamID_Pure();
	struct FSteamID GetServerSteamID_PureCompact();
	void LogOff();
	void LogOn(const class FString& Token);
	void LogOnAnonymous();
	bool RequestUserGroupStatus(const struct FSteamID& SteamIDUser, const struct FSteamID& SteamIDGroup);
	void SetAdvertiseServerActive(bool bActive);
	void SetBotPlayerCount(int32 BotPlayers);
	void SetDedicatedServer(bool bDedicated);
	void SetGameData(const class FString& GameData);
	void SetGameDescription(const class FString& GameDescription);
	void SetGameTags(const class FString& GameTags);
	void SetHeartbeatInterval(int32 HeartbeatInterval);
	void SetKeyValue(const class FString& Key, const class FString& Value);
	void SetMapName(const class FString& MapName);
	void SetMaxPlayerCount(int32 PlayersMax);
	void SetModDir(const class FString& ModDir);
	void SetPasswordProtected(bool bPasswordProtected);
	void SetProduct(const class FString& Product);
	void SetRegion(const class FString& Region);
	void SetServerName(const class FString& ServerName);
	void SetSpectatorPort(int32 SpectatorPort);
	void SetSpectatorServerName(const class FString& SpectatorServerName);
	ESteamUserHasLicenseForAppResult UserHasLicenseForApp(const struct FSteamID& SteamID, int32 AppID);
	bool WasRestartRequested();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamGameServer">();
	}
	static class USteamGameServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamGameServer>();
	}
};
static_assert(alignof(USteamGameServer) == 0x000008, "Wrong alignment on USteamGameServer");
static_assert(sizeof(USteamGameServer) == 0x000158, "Wrong size on USteamGameServer");
static_assert(offsetof(USteamGameServer, GSPolicyResponse) == 0x000068, "Member 'USteamGameServer::GSPolicyResponse' has a wrong offset!");
static_assert(offsetof(USteamGameServer, GSClientGroupStatus) == 0x000078, "Member 'USteamGameServer::GSClientGroupStatus' has a wrong offset!");
static_assert(offsetof(USteamGameServer, GSValidateAuthTicketResponse) == 0x000088, "Member 'USteamGameServer::GSValidateAuthTicketResponse' has a wrong offset!");
static_assert(offsetof(USteamGameServer, GSClientApprove) == 0x000098, "Member 'USteamGameServer::GSClientApprove' has a wrong offset!");
static_assert(offsetof(USteamGameServer, GSClientDeny) == 0x0000A8, "Member 'USteamGameServer::GSClientDeny' has a wrong offset!");

// Class SteamCore.GameServerStats
// 0x0030 (0x0098 - 0x0068)
class UGameServerStats final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             GSStatsUnloaded;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClearUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Name_0);
	bool GetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Name_0, bool* bAchieved);
	bool GetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Name_0, float* Data);
	bool GetUserStatInt(const struct FSteamID& SteamIDUser, const class FString& Name_0, int32* Data);
	void ServerRequestUserStats(const TDelegate<void(struct FGSStatsReceived& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDUser);
	void ServerStoreUserStats(const TDelegate<void(struct FGSStatsStored& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDUser);
	bool SetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Name_0);
	bool SetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Name_0, float Data);
	bool SetUserStatInt(const struct FSteamID& SteamIDUser, const class FString& Name_0, int32 Data);
	bool UpdateUserAvgRateStat(const struct FSteamID& SteamIDUser, const class FString& Name_0, float CountThisSession, float SessionLength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameServerStats">();
	}
	static class UGameServerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameServerStats>();
	}
};
static_assert(alignof(UGameServerStats) == 0x000008, "Wrong alignment on UGameServerStats");
static_assert(sizeof(UGameServerStats) == 0x000098, "Wrong size on UGameServerStats");
static_assert(offsetof(UGameServerStats, GSStatsUnloaded) == 0x000068, "Member 'UGameServerStats::GSStatsUnloaded' has a wrong offset!");

// Class SteamCore.Input
// 0x0000 (0x0068 - 0x0068)
class UInput final : public USteamCoreSubsystem
{
public:
	void ActivateActionSet(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle);
	void ActivateActionSetLayer(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetLayerHandle);
	void DeactivateActionSetLayer(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetLayerHandle);
	void DeactivateAllActionSetLayers(const struct FInputHandle& Handle);
	ESteamCoreInputActionOrigin GetActionOriginFromXboxOrigin(const struct FInputHandle& Handle, ESteamCoreXboxOrigin Origin);
	struct FInputActionSetHandle GetActionSetHandle(const class FString& ActionSetName);
	int32 GetActiveActionSetLayers(const struct FInputHandle& Handle, TArray<struct FInputActionSetHandle>* Data);
	struct FInputAnalogActionData GetAnalogActionData(const struct FInputHandle& Handle, const struct FInputAnalogActionHandle& AnalogActionHandle);
	struct FInputAnalogActionHandle GetAnalogActionHandle(const class FString& PszActionName);
	int32 GetAnalogActionOrigins(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle, const struct FInputAnalogActionHandle& AnalogActionHandle, TArray<ESteamCoreInputActionOrigin>* OriginsOut);
	int32 GetConnectedControllers(TArray<struct FInputHandle>* OutHandles);
	struct FInputHandle GetControllerForGamepadIndex(int32 Index_0);
	struct FInputActionSetHandle GetCurrentActionSet(const struct FInputHandle& Handle);
	bool GetDeviceBindingRevision(const struct FInputHandle& Handle, int32* Major, int32* Minor);
	struct FInputDigitalActionData GetDigitalActionData(const struct FInputHandle& Handle, const struct FInputDigitalActionHandle& DigitalActionHandle);
	struct FInputDigitalActionHandle GetDigitalActionHandle(const class FString& PszActionName);
	int32 GetDigitalActionOrigins(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle, const struct FInputDigitalActionHandle& DigitalActionHandle, TArray<ESteamCoreInputActionOrigin>* OriginsOut);
	int32 GetGamepadIndexForController(const struct FInputHandle& Handle);
	class FString GetGlyphForActionOrigin(ESteamCoreInputActionOrigin Origin);
	class FString GetGlyphForXboxOrigin(ESteamCoreXboxOrigin Origin);
	ESteamCoreInputType GetInputTypeForHandle(const struct FInputHandle& Handle);
	struct FInputMotionData GetMotionData(const struct FInputHandle& Handle);
	int32 GetRemotePlaySessionID(const struct FInputHandle& Handle);
	class FString GetStringForActionOrigin(ESteamCoreInputActionOrigin Origin);
	class FString GetStringForXboxOrigin(ESteamCoreXboxOrigin Origin);
	bool Init();
	void SetLEDColor(const struct FInputHandle& Handle, uint8 ColorR, uint8 ColorG, uint8 ColorB, ESteamCoreInputLEDFlag Flags_0);
	bool ShowBindingPanel(const struct FInputHandle& Handle);
	bool Shutdown();
	void StopAnalogActionMomentum(const struct FInputHandle& Handle, const struct FInputAnalogActionHandle& EAction);
	ESteamCoreInputActionOrigin TranslateActionOrigin(ESteamCoreInputType DestinationInputType, ESteamCoreInputActionOrigin SourceOrigin);
	void TriggerHapticPulse(const struct FInputHandle& Handle, ESteamCoreControllerPad TargetPad, uint8 DurationMicroSec);
	void TriggerRepeatedHapticPulse(const struct FInputHandle& Handle, ESteamCoreControllerPad TargetPad, uint8 DurationMicroSec, uint8 OffMicroSec, uint8 Repeat, uint8 Flags_0);
	void TriggerVibration(const struct FInputHandle& Handle, uint8 LeftSpeed, uint8 RightSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Input">();
	}
	static class UInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInput>();
	}
};
static_assert(alignof(UInput) == 0x000008, "Wrong alignment on UInput");
static_assert(sizeof(UInput) == 0x000068, "Wrong size on UInput");

// Class SteamCore.Inventory
// 0x0120 (0x0188 - 0x0068)
class UInventory final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             SteamInventoryResultReady;                         // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryDefinitionUpdate;                    // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryFullUpdate;                          // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryStartPurchaseResult;                 // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryRequestPricesResultDelegate;         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamInventoryEligiblePromoItemDefIDs;             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0xC0];                                      // 0x00C8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AddPromoItem(struct FSteamInventoryResult* Result, const struct FSteamItemDef& ItemDef);
	static bool AddPromoItems(struct FSteamInventoryResult* OutResult, const TArray<struct FSteamItemDef>& ItemDefs);
	static bool CheckResultSteamID(const struct FSteamInventoryResult& Handle, const struct FSteamID& SteamIDExpected);
	static bool ConsumeItem(struct FSteamInventoryResult* Result, const struct FSteamItemInstanceID& ItemConsume, int32 Quantity);
	static bool DeserializeResult(struct FSteamInventoryResult* Result, const TArray<uint8>& Buffer, bool bReservedMustBeFalse);
	static void DestroyResult(const struct FSteamInventoryResult& Handle);
	static bool ExchangeItems(struct FSteamInventoryResult* Result, const TArray<struct FSteamItemDef>& ArrayGenerate, const TArray<int32>& ArrayGenerateQuantity, const TArray<struct FSteamItemInstanceID>& ArrayDestroy, const TArray<int32>& ArrayDestroyQuantity);
	static bool GenerateItems(struct FSteamInventoryResult* Result, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity);
	static bool GetAllItems(struct FSteamInventoryResult* Handle);
	static bool GetEligiblePromoItemDefinitionIDs(const struct FSteamID& SteamID, TArray<struct FSteamItemDef>* ItemDefs);
	static bool GetItemDefinitionIDs(TArray<struct FSteamItemDef>* ItemDefs);
	static bool GetItemDefinitionProperty(const struct FSteamItemDef& ItemDef, const class FString& PropertyName, class FString* Value);
	static bool GetItemPrice(const struct FSteamItemDef& ItemDef, int32* Price, int32* BasePrice);
	static bool GetItemsByID(struct FSteamInventoryResult* InventoryResult, const TArray<struct FSteamItemInstanceID>& InstanceIDs);
	static bool GetItemsWithPrices(TArray<struct FSteamItemDef>* ItemDefs, TArray<int32>* Prices, TArray<int32>* BasePrices);
	static int32 GetNumItemsWithPrices();
	static bool GetResultItemProperty(const struct FSteamInventoryResult& Handle, int32 ItemIndex, const class FString& PropertyName, class FString* Value);
	static bool GetResultItems(const struct FSteamInventoryResult& Handle, TArray<struct FSteamItemDetails>* Items);
	static ESteamResult GetResultStatus(const struct FSteamInventoryResult& Handle);
	static int32 GetResultTimestamp(const struct FSteamInventoryResult& Handle);
	static bool GrantPromoItems(struct FSteamInventoryResult* Result);
	static bool LoadItemDefinitions();
	static bool RemoveProperty(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName);
	static bool SerializeResult(const struct FSteamInventoryResult& Handle, TArray<uint8>* Buffer);
	static bool SetPropertyBool(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, bool bValue);
	static bool SetPropertyFloat(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, float Value);
	static bool SetPropertyInt(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, int32 Value);
	static bool SetPropertyString(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, const class FString& Value);
	static struct FSteamInventoryUpdateHandle StartUpdateProperties();
	static bool SubmitUpdateProperties(const struct FSteamInventoryUpdateHandle& Handle, struct FSteamInventoryResult* ResultHandle);
	static bool TransferItemQuantity(struct FSteamInventoryResult* Result, const struct FSteamItemInstanceID& ItemIDSource, int32 Quantity, const struct FSteamItemInstanceID& ItemIDDest);
	static bool TriggerItemDrop(struct FSteamInventoryResult* Result, const struct FSteamItemDef& ListDefinition);

	void RequestEligiblePromoItemDefinitionsIDs(const TDelegate<void(struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void RequestPrices(const TDelegate<void(struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful)>& Callback);
	void StartPurchase(const TDelegate<void(struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Inventory">();
	}
	static class UInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventory>();
	}
};
static_assert(alignof(UInventory) == 0x000008, "Wrong alignment on UInventory");
static_assert(sizeof(UInventory) == 0x000188, "Wrong size on UInventory");
static_assert(offsetof(UInventory, SteamInventoryResultReady) == 0x000068, "Member 'UInventory::SteamInventoryResultReady' has a wrong offset!");
static_assert(offsetof(UInventory, SteamInventoryDefinitionUpdate) == 0x000078, "Member 'UInventory::SteamInventoryDefinitionUpdate' has a wrong offset!");
static_assert(offsetof(UInventory, SteamInventoryFullUpdate) == 0x000088, "Member 'UInventory::SteamInventoryFullUpdate' has a wrong offset!");
static_assert(offsetof(UInventory, SteamInventoryStartPurchaseResult) == 0x000098, "Member 'UInventory::SteamInventoryStartPurchaseResult' has a wrong offset!");
static_assert(offsetof(UInventory, SteamInventoryRequestPricesResultDelegate) == 0x0000A8, "Member 'UInventory::SteamInventoryRequestPricesResultDelegate' has a wrong offset!");
static_assert(offsetof(UInventory, SteamInventoryEligiblePromoItemDefIDs) == 0x0000B8, "Member 'UInventory::SteamInventoryEligiblePromoItemDefIDs' has a wrong offset!");

// Class SteamCore.SteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs
// 0x0010 (0x0048 - 0x0038)
class USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs* RequestEligiblePromoItemDefinitionsIDsAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs">();
	}
	static class USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs>();
	}
};
static_assert(alignof(USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs) == 0x000008, "Wrong alignment on USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs");
static_assert(sizeof(USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs) == 0x000048, "Wrong size on USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs");
static_assert(offsetof(USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs, OnCallback) == 0x000038, "Member 'USteamCoreInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreInventoryAsyncActionRequestPricesResult
// 0x0010 (0x0048 - 0x0038)
class USteamCoreInventoryAsyncActionRequestPricesResult final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreInventoryAsyncActionRequestPricesResult* RequestPricesAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreInventoryAsyncActionRequestPricesResult">();
	}
	static class USteamCoreInventoryAsyncActionRequestPricesResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreInventoryAsyncActionRequestPricesResult>();
	}
};
static_assert(alignof(USteamCoreInventoryAsyncActionRequestPricesResult) == 0x000008, "Wrong alignment on USteamCoreInventoryAsyncActionRequestPricesResult");
static_assert(sizeof(USteamCoreInventoryAsyncActionRequestPricesResult) == 0x000048, "Wrong size on USteamCoreInventoryAsyncActionRequestPricesResult");
static_assert(offsetof(USteamCoreInventoryAsyncActionRequestPricesResult, OnCallback) == 0x000038, "Member 'USteamCoreInventoryAsyncActionRequestPricesResult::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreInventoryAsyncActionStartPurchaseResult
// 0x0010 (0x0048 - 0x0038)
class USteamCoreInventoryAsyncActionStartPurchaseResult final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreInventoryAsyncActionStartPurchaseResult* StartPurchaseAsync(class UObject* WorldContextObject, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity, float Timeout);

	void HandleCallback(const struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreInventoryAsyncActionStartPurchaseResult">();
	}
	static class USteamCoreInventoryAsyncActionStartPurchaseResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreInventoryAsyncActionStartPurchaseResult>();
	}
};
static_assert(alignof(USteamCoreInventoryAsyncActionStartPurchaseResult) == 0x000008, "Wrong alignment on USteamCoreInventoryAsyncActionStartPurchaseResult");
static_assert(sizeof(USteamCoreInventoryAsyncActionStartPurchaseResult) == 0x000048, "Wrong size on USteamCoreInventoryAsyncActionStartPurchaseResult");
static_assert(offsetof(USteamCoreInventoryAsyncActionStartPurchaseResult, OnCallback) == 0x000038, "Member 'USteamCoreInventoryAsyncActionStartPurchaseResult::OnCallback' has a wrong offset!");

// Class SteamCore.Matchmaking
// 0x01B0 (0x0218 - 0x0068)
class UMatchmaking final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             FavoritesListAccountsUpdated;                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FavoritesListChanged;                              // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyChatMsg;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyChatUpdate;                                   // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyDataUpdate;                                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyEnter;                                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyGameCreated;                                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyInvite;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LobbyKicked;                                       // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x120];                                     // 0x00F8(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 AddFavoriteGame(int32 AppID, const class FString& IP, int32 ConnectionPort, int32 QueryPort, const TArray<ESteamFavoriteFlags>& Flags_0, int32 TimeLastPlayedOnServer);
	static void AddRequestLobbyListCompatibleMembersFilter(const struct FSteamID& SteamIDLobby);
	static void AddRequestLobbyListDistanceFilter(ESteamLobbyDistanceFilter LobbyDistanceFilter);
	static void AddRequestLobbyListFilterSlotsAvailable(int32 SlotsAvailable);
	static void AddRequestLobbyListNearValueFilter(const class FString& KeyToMatch, int32 ValueToBeCloseTo);
	static void AddRequestLobbyListNumericalFilter(const class FString& KeyToMatch, int32 ValueToMatch, ESteamLobbyComparison ComparisonType);
	static void AddRequestLobbyListResultCountFilter(int32 MaxResults);
	static void AddRequestLobbyListStringFilter(const class FString& KeyToMatch, const class FString& ValueToMatch, ESteamLobbyComparison ComparisonType);
	static bool DeleteLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key);
	static bool GetFavoriteGame(int32 Game, int32* AppID, class FString* IP, int32* ConnectionPort, int32* QueryPort, TArray<ESteamFavoriteFlags>* Flags_0, int32* TimeLastPlayedOnServer);
	static int32 GetFavoriteGameCount();
	static struct FSteamID GetLobbyByIndex(int32 Lobby);
	static int32 GetLobbyChatEntry(const struct FSteamID& SteamIDLobby, int32 MessageID, struct FSteamID* SteamIDUser, class FString* Message, ESteamChatEntryType* ChatEntryType);
	static class FString GetLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key);
	static bool GetLobbyDataByIndex(const struct FSteamID& SteamIDLobby, int32 LobbyData, class FString* Key, class FString* Value);
	static int32 GetLobbyDataCount(const struct FSteamID& SteamIDLobby);
	static bool GetLobbyGameServer(const struct FSteamID& SteamIDLobby, class FString* GameServerIP, int32* GameServerPort, struct FSteamID* SteamIDGameServer);
	static struct FSteamID GetLobbyMemberByIndex(const struct FSteamID& SteamIDLobby, int32 Member);
	static class FString GetLobbyMemberData(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDUser, const class FString& Key);
	static int32 GetLobbyMemberLimit(const struct FSteamID& SteamIDLobby);
	static struct FSteamID GetLobbyOwner(const struct FSteamID& SteamIDLobby);
	static int32 GetNumLobbyMembers(const struct FSteamID& SteamIDLobby);
	static bool InviteUserToLobby(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDInvitee);
	static void LeaveLobby(const struct FSteamID& SteamIDLobby);
	static bool RemoveFavoriteGame(int32 AppID, const class FString& IP, int32 ConnectionPort, int32 QueryPort, const TArray<ESteamFavoriteFlags>& Flags_0);
	static bool RequestLobbyData(const struct FSteamID& SteamIDLobby);
	static bool SendLobbyChatMsg(const struct FSteamID& SteamIDLobby, const class FString& Message);
	static bool SetLinkedLobby(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDLobbyDependent);
	static bool SetLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key, const class FString& Value);
	static void SetLobbyGameServer(const struct FSteamID& SteamIDLobby, const class FString& GameServerIP, int32 GameServerPort, const struct FSteamID& SteamIDGameServer);
	static bool SetLobbyJoinable(const struct FSteamID& SteamIDLobby, bool bLobbyJoinable);
	static void SetLobbyMemberData(const struct FSteamID& SteamIDLobby, const class FString& Key, const class FString& Value);
	static bool SetLobbyMemberLimit(const struct FSteamID& SteamIDLobby, int32 MaxMembers);
	static bool SetLobbyOwner(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDNewOwner);
	static bool SetLobbyType(const struct FSteamID& SteamIDLobby, ESteamLobbyType LobbyType);

	void CreateLobby(const TDelegate<void(struct FCreateLobbyData& Data, bool bWasSuccessful)>& Callback, ESteamLobbyType LobbyType, int32 MaxMembers);
	void JoinLobby(const TDelegate<void(struct FJoinLobbyData& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDLobby);
	void RequestLobbyList(const TDelegate<void(struct FLobbyMatchList& Data, bool bWasSuccessful)>& Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Matchmaking">();
	}
	static class UMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmaking>();
	}
};
static_assert(alignof(UMatchmaking) == 0x000008, "Wrong alignment on UMatchmaking");
static_assert(sizeof(UMatchmaking) == 0x000218, "Wrong size on UMatchmaking");
static_assert(offsetof(UMatchmaking, FavoritesListAccountsUpdated) == 0x000068, "Member 'UMatchmaking::FavoritesListAccountsUpdated' has a wrong offset!");
static_assert(offsetof(UMatchmaking, FavoritesListChanged) == 0x000078, "Member 'UMatchmaking::FavoritesListChanged' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyChatMsg) == 0x000088, "Member 'UMatchmaking::LobbyChatMsg' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyChatUpdate) == 0x000098, "Member 'UMatchmaking::LobbyChatUpdate' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyDataUpdate) == 0x0000A8, "Member 'UMatchmaking::LobbyDataUpdate' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyEnter) == 0x0000B8, "Member 'UMatchmaking::LobbyEnter' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyGameCreated) == 0x0000C8, "Member 'UMatchmaking::LobbyGameCreated' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyInvite) == 0x0000D8, "Member 'UMatchmaking::LobbyInvite' has a wrong offset!");
static_assert(offsetof(UMatchmaking, LobbyKicked) == 0x0000E8, "Member 'UMatchmaking::LobbyKicked' has a wrong offset!");

// Class SteamCore.SteamCoreMatchmakingAsyncActionCreateLobby
// 0x0010 (0x0048 - 0x0038)
class USteamCoreMatchmakingAsyncActionCreateLobby final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreMatchmakingAsyncActionCreateLobby* CreateLobbyAsync(class UObject* WorldContextObject, ESteamLobbyType LobbyType, int32 MaxMembers, float Timeout);

	void HandleCallback(const struct FCreateLobbyData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreMatchmakingAsyncActionCreateLobby">();
	}
	static class USteamCoreMatchmakingAsyncActionCreateLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreMatchmakingAsyncActionCreateLobby>();
	}
};
static_assert(alignof(USteamCoreMatchmakingAsyncActionCreateLobby) == 0x000008, "Wrong alignment on USteamCoreMatchmakingAsyncActionCreateLobby");
static_assert(sizeof(USteamCoreMatchmakingAsyncActionCreateLobby) == 0x000048, "Wrong size on USteamCoreMatchmakingAsyncActionCreateLobby");
static_assert(offsetof(USteamCoreMatchmakingAsyncActionCreateLobby, OnCallback) == 0x000038, "Member 'USteamCoreMatchmakingAsyncActionCreateLobby::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreMatchmakingAsyncActionRequestLobbyList
// 0x0010 (0x0048 - 0x0038)
class USteamCoreMatchmakingAsyncActionRequestLobbyList final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreMatchmakingAsyncActionRequestLobbyList* RequestLobbyListAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FLobbyMatchList& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreMatchmakingAsyncActionRequestLobbyList">();
	}
	static class USteamCoreMatchmakingAsyncActionRequestLobbyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreMatchmakingAsyncActionRequestLobbyList>();
	}
};
static_assert(alignof(USteamCoreMatchmakingAsyncActionRequestLobbyList) == 0x000008, "Wrong alignment on USteamCoreMatchmakingAsyncActionRequestLobbyList");
static_assert(sizeof(USteamCoreMatchmakingAsyncActionRequestLobbyList) == 0x000048, "Wrong size on USteamCoreMatchmakingAsyncActionRequestLobbyList");
static_assert(offsetof(USteamCoreMatchmakingAsyncActionRequestLobbyList, OnCallback) == 0x000038, "Member 'USteamCoreMatchmakingAsyncActionRequestLobbyList::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreMatchmakingAsyncActionJoinLobby
// 0x0010 (0x0048 - 0x0038)
class USteamCoreMatchmakingAsyncActionJoinLobby final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreMatchmakingAsyncActionJoinLobby* JoinLobbyAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDLobby, float Timeout);

	void HandleCallback(const struct FJoinLobbyData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreMatchmakingAsyncActionJoinLobby">();
	}
	static class USteamCoreMatchmakingAsyncActionJoinLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreMatchmakingAsyncActionJoinLobby>();
	}
};
static_assert(alignof(USteamCoreMatchmakingAsyncActionJoinLobby) == 0x000008, "Wrong alignment on USteamCoreMatchmakingAsyncActionJoinLobby");
static_assert(sizeof(USteamCoreMatchmakingAsyncActionJoinLobby) == 0x000048, "Wrong size on USteamCoreMatchmakingAsyncActionJoinLobby");
static_assert(offsetof(USteamCoreMatchmakingAsyncActionJoinLobby, OnCallback) == 0x000038, "Member 'USteamCoreMatchmakingAsyncActionJoinLobby::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreCreateSession
// 0x0108 (0x0140 - 0x0038)
class USteamCoreCreateSession final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0xE8];                                      // 0x0058(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreCreateSession* CreateSteamCoreSession(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSetting>& SessionSettings, const class FString& SessionName, int32 MaxPlayers, bool bUseLAN, bool bAllowInvites, bool bUsesPresence, bool bAllowJoinViaPresence, bool bAllowJoinViaPresenceFriendsOnly, bool bAntiCheatProtected, bool bUsesStats, bool bShouldAdvertise, bool bUseLobbiesVoiceChatIfAvailable, float Timeout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreCreateSession">();
	}
	static class USteamCoreCreateSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreCreateSession>();
	}
};
static_assert(alignof(USteamCoreCreateSession) == 0x000008, "Wrong alignment on USteamCoreCreateSession");
static_assert(sizeof(USteamCoreCreateSession) == 0x000140, "Wrong size on USteamCoreCreateSession");
static_assert(offsetof(USteamCoreCreateSession, OnSuccess) == 0x000038, "Member 'USteamCoreCreateSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(USteamCoreCreateSession, OnFailure) == 0x000048, "Member 'USteamCoreCreateSession::OnFailure' has a wrong offset!");

// Class SteamCore.SteamCoreFindSession
// 0x00A0 (0x00D8 - 0x0038)
class USteamCoreFindSession final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x90];                                      // 0x0048(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreFindSession* FindSteamCoreSessions(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSearchSetting>& SearchSettings, int32 MaxResults, bool bUseLAN, ESteamSessionFindType ServerType, bool bEmptyServersOnly, bool bSecureServersOnly, float Timeout);

	void OnCompleted(bool bSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreFindSession">();
	}
	static class USteamCoreFindSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreFindSession>();
	}
};
static_assert(alignof(USteamCoreFindSession) == 0x000008, "Wrong alignment on USteamCoreFindSession");
static_assert(sizeof(USteamCoreFindSession) == 0x0000D8, "Wrong size on USteamCoreFindSession");
static_assert(offsetof(USteamCoreFindSession, OnCallback) == 0x000038, "Member 'USteamCoreFindSession::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreDestroySession
// 0x0040 (0x0078 - 0x0038)
class USteamCoreDestroySession final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreDestroySession* DestroySteamCoreSession(class UObject* WorldContextObject, float Timeout);

	void OnCompleted(class FName SessionName, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreDestroySession">();
	}
	static class USteamCoreDestroySession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreDestroySession>();
	}
};
static_assert(alignof(USteamCoreDestroySession) == 0x000008, "Wrong alignment on USteamCoreDestroySession");
static_assert(sizeof(USteamCoreDestroySession) == 0x000078, "Wrong size on USteamCoreDestroySession");
static_assert(offsetof(USteamCoreDestroySession, OnSuccess) == 0x000038, "Member 'USteamCoreDestroySession::OnSuccess' has a wrong offset!");
static_assert(offsetof(USteamCoreDestroySession, OnFailure) == 0x000048, "Member 'USteamCoreDestroySession::OnFailure' has a wrong offset!");

// Class SteamCore.SteamCoreUpdateSession
// 0x0030 (0x0068 - 0x0038)
class USteamCoreUpdateSession final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USteamCoreUpdateSession* UpdateSteamCoreSession(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSearchSetting>& Settings, const class FString& SessionName, int32 MaxPlayers);

	void OnCompleted(class FName SessionName, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUpdateSession">();
	}
	static class USteamCoreUpdateSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUpdateSession>();
	}
};
static_assert(alignof(USteamCoreUpdateSession) == 0x000008, "Wrong alignment on USteamCoreUpdateSession");
static_assert(sizeof(USteamCoreUpdateSession) == 0x000068, "Wrong size on USteamCoreUpdateSession");
static_assert(offsetof(USteamCoreUpdateSession, OnCallback) == 0x000038, "Member 'USteamCoreUpdateSession::OnCallback' has a wrong offset!");

// Class SteamCore.MatchmakingServers
// 0x0000 (0x0068 - 0x0068)
class UMatchmakingServers final : public USteamCoreSubsystem
{
public:
	void PingServer(const TDelegate<void(struct FGameServerItem& Data, bool bWasSuccessful)>& Callback, const class FString& IP, int32 QueryPort);
	void RequestFavoritesServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestFriendsServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestHistoryServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestInternetServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestLANServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void RequestSpectatorServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	void ServerRules(const TDelegate<void(TArray<struct FGameServerRule>& Data, bool bWasSuccessful)>& Callback, const class FString& IP, int32 QueryPort);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingServers">();
	}
	static class UMatchmakingServers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingServers>();
	}
};
static_assert(alignof(UMatchmakingServers) == 0x000008, "Wrong alignment on UMatchmakingServers");
static_assert(sizeof(UMatchmakingServers) == 0x000068, "Wrong size on UMatchmakingServers");

// Class SteamCore.SteamCoreMatchmakingServersAsyncActionPingServer
// 0x0010 (0x0048 - 0x0038)
class USteamCoreMatchmakingServersAsyncActionPingServer final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void CancelPingQueries(class UObject* WorldContextObject);
	static class USteamCoreMatchmakingServersAsyncActionPingServer* PingServerAsync(class UObject* WorldContextObject, const class FString& IP, int32 Port, float Timeout);

	void HandleCallback(const struct FGameServerItem& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreMatchmakingServersAsyncActionPingServer">();
	}
	static class USteamCoreMatchmakingServersAsyncActionPingServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreMatchmakingServersAsyncActionPingServer>();
	}
};
static_assert(alignof(USteamCoreMatchmakingServersAsyncActionPingServer) == 0x000008, "Wrong alignment on USteamCoreMatchmakingServersAsyncActionPingServer");
static_assert(sizeof(USteamCoreMatchmakingServersAsyncActionPingServer) == 0x000048, "Wrong size on USteamCoreMatchmakingServersAsyncActionPingServer");
static_assert(offsetof(USteamCoreMatchmakingServersAsyncActionPingServer, OnCallback) == 0x000038, "Member 'USteamCoreMatchmakingServersAsyncActionPingServer::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreMatchmakingServersAsyncActionRequestServerList
// 0x0020 (0x0058 - 0x0038)
class USteamCoreMatchmakingServersAsyncActionRequestServerList final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshCompleted;                                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void CancelServerListQueries(class UObject* WorldContextObject);
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* RequestFavoritesServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* RequestFriendsServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* RequestHistoryServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* RequestInternetServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* RequestLANServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* RequestSpectatorServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter);

	void HandleCallback(const struct FGameServerItem& Data);
	void HandleServerListFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreMatchmakingServersAsyncActionRequestServerList">();
	}
	static class USteamCoreMatchmakingServersAsyncActionRequestServerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreMatchmakingServersAsyncActionRequestServerList>();
	}
};
static_assert(alignof(USteamCoreMatchmakingServersAsyncActionRequestServerList) == 0x000008, "Wrong alignment on USteamCoreMatchmakingServersAsyncActionRequestServerList");
static_assert(sizeof(USteamCoreMatchmakingServersAsyncActionRequestServerList) == 0x000058, "Wrong size on USteamCoreMatchmakingServersAsyncActionRequestServerList");
static_assert(offsetof(USteamCoreMatchmakingServersAsyncActionRequestServerList, OnCallback) == 0x000038, "Member 'USteamCoreMatchmakingServersAsyncActionRequestServerList::OnCallback' has a wrong offset!");
static_assert(offsetof(USteamCoreMatchmakingServersAsyncActionRequestServerList, OnRefreshCompleted) == 0x000048, "Member 'USteamCoreMatchmakingServersAsyncActionRequestServerList::OnRefreshCompleted' has a wrong offset!");

// Class SteamCore.SteamCoreMatchmakingServersAsyncActionServerRules
// 0x0010 (0x0048 - 0x0038)
class USteamCoreMatchmakingServersAsyncActionServerRules final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void CancelServerRulesQueries(class UObject* WorldContextObject);
	static class USteamCoreMatchmakingServersAsyncActionServerRules* ServerRulesAsync(class UObject* WorldContextObject, const class FString& IP, int32 QueryPort, float Timeout);

	void HandleCallback(const TArray<struct FGameServerRule>& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreMatchmakingServersAsyncActionServerRules">();
	}
	static class USteamCoreMatchmakingServersAsyncActionServerRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreMatchmakingServersAsyncActionServerRules>();
	}
};
static_assert(alignof(USteamCoreMatchmakingServersAsyncActionServerRules) == 0x000008, "Wrong alignment on USteamCoreMatchmakingServersAsyncActionServerRules");
static_assert(sizeof(USteamCoreMatchmakingServersAsyncActionServerRules) == 0x000048, "Wrong size on USteamCoreMatchmakingServersAsyncActionServerRules");
static_assert(offsetof(USteamCoreMatchmakingServersAsyncActionServerRules, OnCallback) == 0x000038, "Member 'USteamCoreMatchmakingServersAsyncActionServerRules::OnCallback' has a wrong offset!");

// Class SteamCore.ServerFilter
// 0x0010 (0x0038 - 0x0028)
class UServerFilter final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFilterAnd(const class FString& Value);
	void AddFilterDedicated();
	void AddFilterGameAddr(const class FString& Value);
	void AddFilterGameDataAnd(const class FString& Value);
	void AddFilterGameDataNor(const class FString& Value);
	void AddFilterGameDataOr(const class FString& Value);
	void AddFilterGameTagsAnd(const class FString& Value);
	void AddFilterGameTagsNor(const class FString& Value);
	void AddFilterHasPlayers();
	void AddFilterLinux();
	void AddFilterMap(const class FString& Value);
	void AddFilterName(const class FString& Value);
	void AddFilterNand(const class FString& Value);
	void AddFilterNoPlayers();
	void AddFilterNor(const class FString& Value);
	void AddFilterNotAppId(const class FString& Value);
	void AddFilterNotFull();
	void AddFilterOr(const class FString& Value);
	void AddFilterPassword();
	void AddFilterProxy();
	void AddFilterSecure();
	void AddFilterVersion(const class FString& Value);
	void AddFilterWhitelisted();
	TMap<class FString, class FString> GetFilters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerFilter">();
	}
	static class UServerFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerFilter>();
	}
};
static_assert(alignof(UServerFilter) == 0x000008, "Wrong alignment on UServerFilter");
static_assert(sizeof(UServerFilter) == 0x000038, "Wrong size on UServerFilter");

// Class SteamCore.Music
// 0x0060 (0x00C8 - 0x0068)
class UMusic final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             PlaybackStatusHasChanged;                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VolumeHasChanged;                                  // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BIsEnabled();
	bool BIsPlaying();
	ESteamAudioPlaybackStatus GetPlaybackStatus();
	float GetVolume();
	void Pause();
	void Play();
	void PlayNext();
	void PlayPrevious();
	void SetVolume(float FlVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Music">();
	}
	static class UMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusic>();
	}
};
static_assert(alignof(UMusic) == 0x000008, "Wrong alignment on UMusic");
static_assert(sizeof(UMusic) == 0x0000C8, "Wrong size on UMusic");
static_assert(offsetof(UMusic, PlaybackStatusHasChanged) == 0x000068, "Member 'UMusic::PlaybackStatusHasChanged' has a wrong offset!");
static_assert(offsetof(UMusic, VolumeHasChanged) == 0x000078, "Member 'UMusic::VolumeHasChanged' has a wrong offset!");

// Class SteamCore.Networking
// 0x0060 (0x00C8 - 0x0068)
class UNetworking final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnP2PSessionRequestDelegate;                       // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnP2PSessionConnectFailDelegate;                   // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AcceptP2PSessionWithUser(const struct FSteamID& SteamIDRemote);
	bool AllowP2PPacketRelay(bool bAllow);
	bool CloseP2PChannelWithUser(const struct FSteamID& SteamIDRemote, int32 Channel);
	bool CloseP2PSessionWithUser(const struct FSteamID& SteamIDRemote);
	bool GetP2PSessionState(const struct FSteamID& SteamIDRemote, struct FSteamP2PSessionState* ConnectionState);
	bool IsP2PPacketAvailable(int32* MessageSize, int32 Channel);
	bool ReadP2PPacket(TArray<uint8>* Data, struct FSteamID* OutSteamIdRemote, int32 MessageSize, int32 Channel);
	bool SendP2PPacket(const struct FSteamID& SteamIDRemote, const TArray<uint8>& Data, ESteamP2PSend P2PSendType, int32 Channel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Networking">();
	}
	static class UNetworking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworking>();
	}
};
static_assert(alignof(UNetworking) == 0x000008, "Wrong alignment on UNetworking");
static_assert(sizeof(UNetworking) == 0x0000C8, "Wrong size on UNetworking");
static_assert(offsetof(UNetworking, OnP2PSessionRequestDelegate) == 0x000068, "Member 'UNetworking::OnP2PSessionRequestDelegate' has a wrong offset!");
static_assert(offsetof(UNetworking, OnP2PSessionConnectFailDelegate) == 0x000078, "Member 'UNetworking::OnP2PSessionConnectFailDelegate' has a wrong offset!");

// Class SteamCore.NetworkingUtils
// 0x0000 (0x0068 - 0x0068)
class UNetworkingUtils final : public USteamCoreSubsystem
{
public:
	static void ConvertPingLocationToString(const struct FSteamNetworkPingLocation& Location, class FString* String);
	static bool ParsePingLocationString(const class FString& String, struct FSteamNetworkPingLocation* Result);

	bool CheckPingDataUpToDate(float MaxAgeSeconds);
	int32 EstimatePingTimeBetweenTwoLocations(const struct FSteamNetworkPingLocation& Location1, const struct FSteamNetworkPingLocation& Location2);
	int32 EstimatePingTimeFromLocalHost(const struct FSteamNetworkPingLocation& RemoteLocation);
	float GetLocalPingLocation(struct FSteamNetworkPingLocation* Result);
	void InitRelayNetworkAccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkingUtils">();
	}
	static class UNetworkingUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkingUtils>();
	}
};
static_assert(alignof(UNetworkingUtils) == 0x000008, "Wrong alignment on UNetworkingUtils");
static_assert(sizeof(UNetworkingUtils) == 0x000068, "Wrong size on UNetworkingUtils");

// Class SteamCore.ParentalSettings
// 0x0000 (0x0068 - 0x0068)
class UParentalSettings final : public USteamCoreSubsystem
{
public:
	bool BIsAppBlocked(int32 AppID);
	bool BIsAppInBlockList(int32 AppID);
	bool BIsFeatureBlocked(ESteamParentalFeature Feature);
	bool BIsFeatureInBlockList(ESteamParentalFeature Feature);
	bool BIsParentalLockEnabled();
	bool BIsParentalLockLocked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParentalSettings">();
	}
	static class UParentalSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParentalSettings>();
	}
};
static_assert(alignof(UParentalSettings) == 0x000008, "Wrong alignment on UParentalSettings");
static_assert(sizeof(UParentalSettings) == 0x000068, "Wrong size on UParentalSettings");

// Class SteamCore.SteamParties
// 0x0120 (0x0188 - 0x0068)
class USteamParties final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             JoinPartyDelegate;                                 // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             CreateBeaconDelegate;                              // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReservationNotificationDelegate;                   // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChangeNumOpenSlotsDelegate;                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AvailableBeaconLocationsDelegate;                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ActiveBeaconsDelegate;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0xC0];                                      // 0x00C8(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CancelReservation(const struct FPartyBeaconID& BeaconID, const struct FSteamID& SteamIDUser);
	static bool DestroyBeacon(const struct FPartyBeaconID& BeaconID);
	static bool GetAvailableBeaconLocations(TArray<struct FSteamPartyBeaconLocation>* LocationList, int32 MaxNumLocations);
	static struct FPartyBeaconID GetBeaconByIndex(int32 Index_0);
	static bool GetBeaconDetails(const struct FPartyBeaconID& BeaconID, struct FSteamID* SteamIDBeaconOwner, struct FSteamPartyBeaconLocation* Location, class FString* OutMetadata);
	static bool GetBeaconLocationData(const struct FSteamPartyBeaconLocation& BeaconLocation, ESteamPartiesBeaconLocationData EData, class FString* PCHDataStringOut);
	static int32 GetNumActiveBeacons();
	static bool GetNumAvailableBeaconLocations(int32* NumLocations);
	static void OnReservationCompleted(const struct FPartyBeaconID& BeaconID, const struct FSteamID& SteamIDUser);

	void ChangeNumOpenSlots(const TDelegate<void(struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful)>& Callback, const struct FPartyBeaconID& BeaconID, int32 OpenSlots);
	void CreateBeacon(const TDelegate<void(struct FCreateBeaconData& Data, bool bWasSuccessful)>& Callback, int32 OpenSlots, const struct FSteamPartyBeaconLocation& BeaconLocation, const class FString& ConnectString, const class FString& MetaData);
	void JoinParty(const TDelegate<void(struct FJoinPartyData& Data, bool bWasSuccessful)>& Callback, const struct FPartyBeaconID& BeaconID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamParties">();
	}
	static class USteamParties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamParties>();
	}
};
static_assert(alignof(USteamParties) == 0x000008, "Wrong alignment on USteamParties");
static_assert(sizeof(USteamParties) == 0x000188, "Wrong size on USteamParties");
static_assert(offsetof(USteamParties, JoinPartyDelegate) == 0x000068, "Member 'USteamParties::JoinPartyDelegate' has a wrong offset!");
static_assert(offsetof(USteamParties, CreateBeaconDelegate) == 0x000078, "Member 'USteamParties::CreateBeaconDelegate' has a wrong offset!");
static_assert(offsetof(USteamParties, ReservationNotificationDelegate) == 0x000088, "Member 'USteamParties::ReservationNotificationDelegate' has a wrong offset!");
static_assert(offsetof(USteamParties, ChangeNumOpenSlotsDelegate) == 0x000098, "Member 'USteamParties::ChangeNumOpenSlotsDelegate' has a wrong offset!");
static_assert(offsetof(USteamParties, AvailableBeaconLocationsDelegate) == 0x0000A8, "Member 'USteamParties::AvailableBeaconLocationsDelegate' has a wrong offset!");
static_assert(offsetof(USteamParties, ActiveBeaconsDelegate) == 0x0000B8, "Member 'USteamParties::ActiveBeaconsDelegate' has a wrong offset!");

// Class SteamCore.SteamCoreSteamPartiesAsyncActionJoinParty
// 0x0010 (0x0048 - 0x0038)
class USteamCoreSteamPartiesAsyncActionJoinParty final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreSteamPartiesAsyncActionJoinParty* JoinPartyAsync(class UObject* WorldContextObject, const struct FPartyBeaconID& BeaconID, float Timeout);

	void HandleCallback(const struct FJoinPartyData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreSteamPartiesAsyncActionJoinParty">();
	}
	static class USteamCoreSteamPartiesAsyncActionJoinParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreSteamPartiesAsyncActionJoinParty>();
	}
};
static_assert(alignof(USteamCoreSteamPartiesAsyncActionJoinParty) == 0x000008, "Wrong alignment on USteamCoreSteamPartiesAsyncActionJoinParty");
static_assert(sizeof(USteamCoreSteamPartiesAsyncActionJoinParty) == 0x000048, "Wrong size on USteamCoreSteamPartiesAsyncActionJoinParty");
static_assert(offsetof(USteamCoreSteamPartiesAsyncActionJoinParty, OnCallback) == 0x000038, "Member 'USteamCoreSteamPartiesAsyncActionJoinParty::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreSteamPartiesAsyncActionCreateBeacon
// 0x0010 (0x0048 - 0x0038)
class USteamCoreSteamPartiesAsyncActionCreateBeacon final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreSteamPartiesAsyncActionCreateBeacon* CreateBeaconAsync(class UObject* WorldContextObject, int32 OpenSlots, const struct FSteamPartyBeaconLocation& BeaconLocation, const class FString& ConnectString, const class FString& MetaData, float Timeout);

	void HandleCallback(const struct FCreateBeaconData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreSteamPartiesAsyncActionCreateBeacon">();
	}
	static class USteamCoreSteamPartiesAsyncActionCreateBeacon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreSteamPartiesAsyncActionCreateBeacon>();
	}
};
static_assert(alignof(USteamCoreSteamPartiesAsyncActionCreateBeacon) == 0x000008, "Wrong alignment on USteamCoreSteamPartiesAsyncActionCreateBeacon");
static_assert(sizeof(USteamCoreSteamPartiesAsyncActionCreateBeacon) == 0x000048, "Wrong size on USteamCoreSteamPartiesAsyncActionCreateBeacon");
static_assert(offsetof(USteamCoreSteamPartiesAsyncActionCreateBeacon, OnCallback) == 0x000038, "Member 'USteamCoreSteamPartiesAsyncActionCreateBeacon::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreSteamPartiesAsyncActionChangeNumOpenSlots
// 0x0010 (0x0048 - 0x0038)
class USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots* ChangeNumOpenSlotsAsync(class UObject* WorldContextObject, const struct FPartyBeaconID& BeaconID, int32 OpenSlots, float Timeout);

	void HandleCallback(const struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreSteamPartiesAsyncActionChangeNumOpenSlots">();
	}
	static class USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots>();
	}
};
static_assert(alignof(USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots) == 0x000008, "Wrong alignment on USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots");
static_assert(sizeof(USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots) == 0x000048, "Wrong size on USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots");
static_assert(offsetof(USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots, OnCallback) == 0x000038, "Member 'USteamCoreSteamPartiesAsyncActionChangeNumOpenSlots::OnCallback' has a wrong offset!");

// Class SteamCore.RemotePlay
// 0x0060 (0x00C8 - 0x0068)
class URemotePlay final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             SteamRemotePlaySessionConnected;                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamRemotePlaySessionDisconnected;                // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BGetSessionClientResolution(int32 SessionID, int32* ResolutionX, int32* ResolutionY);
	bool BSendRemotePlayTogetherInvite(const struct FSteamID& SteamIDFriend);
	ESteamCoreDeviceFormFactor GetSessionClientFormFactor(int32 SessionID);
	class FString GetSessionClientName(int32 SessionID);
	int32 GetSessionCount();
	int32 GetSessionID(int32 SessionIndex);
	struct FSteamID GetSessionSteamID(int32 SessionID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemotePlay">();
	}
	static class URemotePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemotePlay>();
	}
};
static_assert(alignof(URemotePlay) == 0x000008, "Wrong alignment on URemotePlay");
static_assert(sizeof(URemotePlay) == 0x0000C8, "Wrong size on URemotePlay");
static_assert(offsetof(URemotePlay, SteamRemotePlaySessionConnected) == 0x000068, "Member 'URemotePlay::SteamRemotePlaySessionConnected' has a wrong offset!");
static_assert(offsetof(URemotePlay, SteamRemotePlaySessionDisconnected) == 0x000078, "Member 'URemotePlay::SteamRemotePlaySessionDisconnected' has a wrong offset!");

// Class SteamCore.RemoteStorage
// 0x00C0 (0x0128 - 0x0068)
class URemoteStorage final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             RemoteStorageUnsubscribePublishedFileResult;       // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemoteStorageSubscribePublishedFileResult;         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemoteStoragePublishedFileUnsubscribed;            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             RemoteStoragePublishedFileSubscribed;              // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x80];                                      // 0x00A8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool FileDelete(const class FString& File);
	static bool FileExists(const class FString& File);
	static bool FileForget(const class FString& File);
	static bool FilePersisted(const class FString& File);
	static int32 FileRead(const class FString& File, TArray<uint8>* Buffer, int32 DataToRead);
	static bool FileReadAsyncComplete(const struct FRemoteStorageFileReadAsyncComplete& ReadCall, TArray<uint8>* Buffer, int32 BytesToRead);
	static bool FileWrite(const class FString& File, const TArray<uint8>& Data);
	static bool FileWriteStreamCancel(const struct FUGCFileWriteStreamHandle& Handle);
	static bool FileWriteStreamClose(const struct FUGCFileWriteStreamHandle& Handle);
	static struct FUGCFileWriteStreamHandle FileWriteStreamOpen(const class FString& File);
	static bool FileWriteStreamWriteChunk(const struct FUGCFileWriteStreamHandle& Handle, const TArray<uint8>& Data);
	static int32 GetCachedUGCCount();
	static struct FSteamUGCHandle GetCachedUGCHandle(int32 ICachedContent);
	static int32 GetFileCount();
	static class FString GetFileNameAndSize(int32 File, int32* FileSizeInBytes);
	static int32 GetFileSize(const class FString& File);
	static int32 GetFileTimestamp(const class FString& File);
	static bool GetQuota(int32* TotalBytes, int32* AvailableBytes);
	static ESteamRemoteStoragePlatform GetSyncPlatforms(const class FString& File);
	static bool GetUGCDetails(const struct FSteamUGCHandle& Handle, int32* AppID, class FString* Name_0, int32* FileSizeInBytes, struct FSteamID* SteamIDOwner);
	static bool GetUGCDownloadProgress(const struct FSteamUGCHandle& Handle, int32* BytesDownloaded, int32* BytesExpected);
	static bool IsCloudEnabledForAccount();
	static bool IsCloudEnabledForApp();
	static void SetCloudEnabledForApp(bool bEnabled);
	static bool SetSyncPlatforms(const class FString& File, ESteamRemoteStoragePlatform RemoteStoragePlatform);
	static int32 UGCRead(const struct FSteamUGCHandle& Content, TArray<uint8>* OutData, int32 DataToRead, int32 Offset, ESteamUGCReadAction Action);

	void FileReadAsync(const TDelegate<void(struct FRemoteStorageFileReadAsyncComplete& Data, bool bWasSuccessful)>& Callback, const class FString& File, int32 Offset, int32 BytesToRead);
	void FileShare(const TDelegate<void(struct FRemoteStorageFileShareResult& Data, bool bWasSuccessful)>& Callback, const class FString& File);
	void FileWriteAsync(const TDelegate<void(struct FRemoteStorageFileWriteAsyncComplete& Data, bool bWasSuccessful)>& Callback, const class FString& File, const TArray<uint8>& Data);
	void UGCDownload(const TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamUGCHandle& Content, int32 Priority);
	void UGCDownloadToLocation(const TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamUGCHandle& Content, const class FString& Location, int32 Priority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoteStorage">();
	}
	static class URemoteStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoteStorage>();
	}
};
static_assert(alignof(URemoteStorage) == 0x000008, "Wrong alignment on URemoteStorage");
static_assert(sizeof(URemoteStorage) == 0x000128, "Wrong size on URemoteStorage");
static_assert(offsetof(URemoteStorage, RemoteStorageUnsubscribePublishedFileResult) == 0x000068, "Member 'URemoteStorage::RemoteStorageUnsubscribePublishedFileResult' has a wrong offset!");
static_assert(offsetof(URemoteStorage, RemoteStorageSubscribePublishedFileResult) == 0x000078, "Member 'URemoteStorage::RemoteStorageSubscribePublishedFileResult' has a wrong offset!");
static_assert(offsetof(URemoteStorage, RemoteStoragePublishedFileUnsubscribed) == 0x000088, "Member 'URemoteStorage::RemoteStoragePublishedFileUnsubscribed' has a wrong offset!");
static_assert(offsetof(URemoteStorage, RemoteStoragePublishedFileSubscribed) == 0x000098, "Member 'URemoteStorage::RemoteStoragePublishedFileSubscribed' has a wrong offset!");

// Class SteamCore.Screenshots
// 0x0060 (0x00C8 - 0x0068)
class UScreenshots final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             ScreenshotReady;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ScreenshotRequested;                               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FScreenshotHandle AddScreenshotToLibrary(const class FString& Filename, const class FString& ThumbnailFilename, int32 Width, int32 Height);
	static struct FScreenshotHandle AddVRScreenshotToLibrary(ESteamVRScreenshotType EType, const class FString& Filename, const class FString& VRFileName);
	static void HookScreenshots(bool bHook);
	static bool IsScreenshotsHooked();
	static bool SetLocation(const struct FScreenshotHandle& Handle, const class FString& Location);
	static bool TagPublishedFile(const struct FScreenshotHandle& Handle, const struct FPublishedFileID& PublishedFileID);
	static bool TagUser(const struct FScreenshotHandle& Handle, const struct FSteamID& SteamID);
	static void TriggerScreenshot();
	static struct FScreenshotHandle WriteScreenshot(const TArray<uint8>& PubRGB, int32 Width, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Screenshots">();
	}
	static class UScreenshots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshots>();
	}
};
static_assert(alignof(UScreenshots) == 0x000008, "Wrong alignment on UScreenshots");
static_assert(sizeof(UScreenshots) == 0x0000C8, "Wrong size on UScreenshots");
static_assert(offsetof(UScreenshots, ScreenshotReady) == 0x000068, "Member 'UScreenshots::ScreenshotReady' has a wrong offset!");
static_assert(offsetof(UScreenshots, ScreenshotRequested) == 0x000078, "Member 'UScreenshots::ScreenshotRequested' has a wrong offset!");

// Class SteamCore.UGC
// 0x0060 (0x00C8 - 0x0068)
class UUGC final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             ItemInstalled;                                     // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DownloadItemResult;                                // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AddExcludedTag(const struct FUGCQueryHandle& Handle, const class FString& TagName);
	static bool AddItemKeyValueTag(const struct FUGCUpdateHandle& Handle, const class FString& Key, const class FString& Value);
	static bool AddItemPreviewFile(const struct FUGCUpdateHandle& Handle, const class FString& PreviewFile, ESteamItemPreviewType Type);
	static bool AddItemPreviewVideo(const struct FUGCUpdateHandle& Handle, const class FString& VideoID);
	static bool AddRequiredKeyValueTag(const struct FUGCQueryHandle& Handle, const class FString& Key, const class FString& Value);
	static bool AddRequiredTag(const struct FUGCQueryHandle& Handle, const class FString& TagName);
	static bool AddRequiredTagGroup(const struct FUGCQueryHandle& Handle, const TArray<class FString>& TagGroups);
	static bool BInitWorkshopForGameServer(int32 WorkshopDepotID, const class FString& Folder);
	static struct FUGCQueryHandle CreateQueryAllUGCRequest(ESteamUGCQuery QueryType, ESteamUGCMatchingUGCType FileType, int32 CreatorAppID, int32 ConsumerAppID, int32 Page);
	static struct FUGCQueryHandle CreateQueryUGCDetailsRequest(const TArray<struct FPublishedFileID>& PublishedFileIDs);
	static struct FUGCQueryHandle CreateQueryUserUGCRequest(const struct FSteamID& SteamID, ESteamUserUGCList ListType, ESteamUGCMatchingUGCType MatchingUGCType, ESteamUserUGCListSortOrder SortOrder, int32 CreatorAppID, int32 ConsumerAppID, int32 Page);
	static bool DownloadItem(const struct FPublishedFileID& PublishedFileID, bool bHighPriority);
	static bool GetItemDownloadInfo(const struct FPublishedFileID& PublishedFileID, int32* BytesDownloaded, int32* BytesTotal);
	static bool GetItemInstallInfo(const struct FPublishedFileID& PublishedFileID, int32* SizeOnDisk, class FString* Folder, int32* Timestamp);
	static int32 GetItemState(const struct FPublishedFileID& PublishedFileID, TArray<ESteamItemState>* States);
	static ESteamItemUpdateStatus GetItemUpdateProgress(const struct FUGCUpdateHandle& Handle, int32* BytesProcessed, int32* BytesTotal);
	static int32 GetNumSubscribedItems();
	static bool GetQueryUGCAdditionalPreview(const struct FUGCQueryHandle& Handle, int32 Index_0, int32 PreviewIndex, class FString* URLOrVideoID, class FString* OriginalFileName, ESteamItemPreviewType* PreviewType);
	static bool GetQueryUGCChildren(const struct FUGCQueryHandle& Handle, int32 Index_0, TArray<struct FPublishedFileID>* PublishedFileIDs, int32 MaxEntries);
	static bool GetQueryUGCKeyValueTag(const struct FUGCQueryHandle& Handle, int32 Index_0, int32 KeyValueTagIndex, class FString* Key, class FString* Value);
	static bool GetQueryUGCMetadata(const struct FUGCQueryHandle& Handle, int32 Index_0, class FString* MetaData, int32 MetadataSize);
	static int32 GetQueryUGCNumAdditionalPreviews(const struct FUGCQueryHandle& Handle, int32 Index_0);
	static int32 GetQueryUGCNumKeyValueTags(const struct FUGCQueryHandle& Handle, int32 Index_0);
	static int32 GetQueryUGCNumTags(const struct FUGCQueryHandle& Handle, int32 Index_0);
	static bool GetQueryUGCPreviewURL(const struct FUGCQueryHandle& Handle, int32 Index_0, class FString* URL);
	static bool GetQueryUGCResult(const struct FUGCQueryHandle& Handle, int32 Index_0, struct FSteamUGCDetails* Details);
	static bool GetQueryUGCStatistic(const struct FUGCQueryHandle& Handle, int32 Index_0, ESteamItemStatistic StatType, class FString* StatValue);
	static bool GetQueryUGCTag(const struct FUGCQueryHandle& Handle, int32 Index_0, int32 IndexTag, class FString* Value);
	static bool GetQueryUGCTagDisplayName(const struct FUGCQueryHandle& Handle, int32 Index_0, int32 IndexTag, class FString* Value);
	static int32 GetSubscribedItems(TArray<struct FPublishedFileID>* PublishedFileIDs, int32 MaxEntries);
	static bool ReleaseQueryUGCRequest(const struct FUGCQueryHandle& Handle);
	static bool RemoveItemKeyValueTags(const struct FUGCUpdateHandle& Handle, const class FString& Key);
	static bool RemoveItemPreview(const struct FUGCUpdateHandle& Handle, int32 Index_0);
	static bool SetAllowCachedResponse(const struct FUGCQueryHandle& Handle, int32 MaxAgeSeconds);
	static bool SetCloudFileNameFilter(const struct FUGCQueryHandle& Handle, const class FString& MatchCloudFileName);
	static bool SetItemContent(const struct FUGCUpdateHandle& Handle, const class FString& ContentFolder);
	static bool SetItemDescription(const struct FUGCUpdateHandle& Handle, const class FString& Description);
	static bool SetItemMetadata(const struct FUGCUpdateHandle& Handle, const class FString& MetaData);
	static bool SetItemPreview(const struct FUGCUpdateHandle& Handle, const class FString& PreviewFile);
	static bool SetItemTags(const struct FUGCUpdateHandle& Handle, const TArray<class FString>& Tags);
	static bool SetItemTitle(const struct FUGCUpdateHandle& Handle, const class FString& Title);
	static bool SetItemUpdateLanguage(const struct FUGCUpdateHandle& Handle, const class FString& Language);
	static bool SetItemVisibility(const struct FUGCUpdateHandle& Handle, ESteamRemoteStoragePublishedFileVisibility Visibility);
	static bool SetLanguage(const struct FUGCQueryHandle& Handle, const class FString& Language);
	static bool SetMatchAnyTag(const struct FUGCQueryHandle& Handle, bool bMatchAnyTag);
	static bool SetRankedByTrendDays(const struct FUGCQueryHandle& Handle, int32 Days);
	static bool SetReturnAdditionalPreviews(const struct FUGCQueryHandle& Handle, bool bReturnAdditionalPreviews);
	static bool SetReturnChildren(const struct FUGCQueryHandle& Handle, bool bReturnChildren);
	static bool SetReturnKeyValueTags(const struct FUGCQueryHandle& Handle, bool bReturnKeyValueTags);
	static bool SetReturnLongDescription(const struct FUGCQueryHandle& Handle, bool bReturnLongDescription);
	static bool SetReturnMetadata(const struct FUGCQueryHandle& Handle, bool bReturnMetadata);
	static bool SetReturnOnlyIDs(const struct FUGCQueryHandle& Handle, bool bReturnOnlyIDs);
	static bool SetReturnPlaytimeStats(const struct FUGCQueryHandle& Handle, int32 Days);
	static bool SetReturnTotalOnly(const struct FUGCQueryHandle& Handle, bool bReturnTotalOnly);
	static bool SetSearchText(const struct FUGCQueryHandle& Handle, const class FString& SearchText);
	static struct FUGCUpdateHandle StartItemUpdate(int32 ConsumerAppID, const struct FPublishedFileID& PublishedFileID);
	static void SuspendDownloads(bool bSuspend);
	static bool UpdateItemPreviewFile(const struct FUGCUpdateHandle& Handle, int32 Index_0, const class FString& PreviewFile);
	static bool UpdateItemPreviewVideo(const struct FUGCUpdateHandle& Handle, int32 Index_0, const class FString& PreviewVideo);

	void AddAppDependency(const TDelegate<void(struct FAddAppDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, int32 AppID);
	void AddDependency(const TDelegate<void(struct FAddUGCDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId);
	void AddItemToFavorites(const TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>& Callback, int32 AppID, const struct FPublishedFileID& PublishedFileID);
	void CreateItem(const TDelegate<void(struct FCreateItemResult& Data, bool bWasSuccessful)>& Callback, int32 ConsumerAppID, ESteamWorkshopFileType FileType);
	void DeleteItem(const TDelegate<void(struct FUGCDeleteItemResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void GetAppDependencies(const TDelegate<void(struct FGetAppDependenciesResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void GetUserItemVote(const TDelegate<void(struct FGetUserItemVoteResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void RemoveAppDependency(const TDelegate<void(struct FRemoveAppDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, int32 AppID);
	void RemoveDependency(const TDelegate<void(struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& ParentPublishedFileID, const struct FPublishedFileID& ChildPublishedFileId);
	void RemoveItemFromFavorites(const TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>& Callback, int32 AppID, const struct FPublishedFileID& PublishedFileID);
	void SendQueryUGCRequest(const TDelegate<void(struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful)>& Callback, const struct FUGCQueryHandle& Handle);
	bool SetAllowLegacyUpload(const struct FUGCUpdateHandle& Handle, bool bAllowLegacyUpload);
	void SetUserItemVote(const TDelegate<void(struct FSetUserItemVoteResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, bool bVoteUp);
	void StartPlaytimeTracking(const TDelegate<void(struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FPublishedFileID>& PublishedFileID);
	void StopPlaytimeTracking(const TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FPublishedFileID>& PublishedFileIDs);
	void StopPlaytimeTrackingForAllItems(const TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback);
	void SubmitItemUpdate(const TDelegate<void(struct FSubmitItemUpdateResult& Data, bool bWasSuccessful)>& Callback, const struct FUGCUpdateHandle& Handle, const class FString& ChangeNote);
	void SubscribeItem(const TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);
	void UnsubscribeItem(const TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGC">();
	}
	static class UUGC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGC>();
	}
};
static_assert(alignof(UUGC) == 0x000008, "Wrong alignment on UUGC");
static_assert(sizeof(UUGC) == 0x0000C8, "Wrong size on UUGC");
static_assert(offsetof(UUGC, ItemInstalled) == 0x000068, "Member 'UUGC::ItemInstalled' has a wrong offset!");
static_assert(offsetof(UUGC, DownloadItemResult) == 0x000078, "Member 'UUGC::DownloadItemResult' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems* StopPlaytimeTrackingForAllItemsAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems">();
	}
	static class USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems");
static_assert(sizeof(USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems");
static_assert(offsetof(USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionStopPlaytimeTrackingForAllItems::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionStopPlaytimeTracking
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionStopPlaytimeTracking final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionStopPlaytimeTracking* StopPlaytimeTrackingAsync(class UObject* WorldContextObject, const TArray<struct FPublishedFileID>& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionStopPlaytimeTracking">();
	}
	static class USteamCoreUGCAsyncActionStopPlaytimeTracking* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionStopPlaytimeTracking>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionStopPlaytimeTracking) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionStopPlaytimeTracking");
static_assert(sizeof(USteamCoreUGCAsyncActionStopPlaytimeTracking) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionStopPlaytimeTracking");
static_assert(offsetof(USteamCoreUGCAsyncActionStopPlaytimeTracking, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionStopPlaytimeTracking::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionStartPlaytimeTracking
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionStartPlaytimeTracking final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionStartPlaytimeTracking* StartPlaytimeTrackingAsync(class UObject* WorldContextObject, const TArray<struct FPublishedFileID>& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionStartPlaytimeTracking">();
	}
	static class USteamCoreUGCAsyncActionStartPlaytimeTracking* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionStartPlaytimeTracking>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionStartPlaytimeTracking) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionStartPlaytimeTracking");
static_assert(sizeof(USteamCoreUGCAsyncActionStartPlaytimeTracking) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionStartPlaytimeTracking");
static_assert(offsetof(USteamCoreUGCAsyncActionStartPlaytimeTracking, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionStartPlaytimeTracking::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionUnsubscribeItem
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionUnsubscribeItem final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionUnsubscribeItem* UnsubscribeItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionUnsubscribeItem">();
	}
	static class USteamCoreUGCAsyncActionUnsubscribeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionUnsubscribeItem>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionUnsubscribeItem) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionUnsubscribeItem");
static_assert(sizeof(USteamCoreUGCAsyncActionUnsubscribeItem) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionUnsubscribeItem");
static_assert(offsetof(USteamCoreUGCAsyncActionUnsubscribeItem, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionUnsubscribeItem::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionSubscribeItem
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionSubscribeItem final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionSubscribeItem* SubscribeItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileIDs, float Timeout);

	void HandleCallback(const struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionSubscribeItem">();
	}
	static class USteamCoreUGCAsyncActionSubscribeItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionSubscribeItem>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionSubscribeItem) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionSubscribeItem");
static_assert(sizeof(USteamCoreUGCAsyncActionSubscribeItem) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionSubscribeItem");
static_assert(offsetof(USteamCoreUGCAsyncActionSubscribeItem, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionSubscribeItem::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionRemoveItemFromFavorites
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionRemoveItemFromFavorites final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionRemoveItemFromFavorites* RemoveItemFromFavoritesAsync(class UObject* WorldContextObject, int32 AppID, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionRemoveItemFromFavorites">();
	}
	static class USteamCoreUGCAsyncActionRemoveItemFromFavorites* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionRemoveItemFromFavorites>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionRemoveItemFromFavorites) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionRemoveItemFromFavorites");
static_assert(sizeof(USteamCoreUGCAsyncActionRemoveItemFromFavorites) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionRemoveItemFromFavorites");
static_assert(offsetof(USteamCoreUGCAsyncActionRemoveItemFromFavorites, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionRemoveItemFromFavorites::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionAddItemToFavorites
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionAddItemToFavorites final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionAddItemToFavorites* AddItemToFavoritesAsync(class UObject* WorldContextObject, int32 AppID, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionAddItemToFavorites">();
	}
	static class USteamCoreUGCAsyncActionAddItemToFavorites* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionAddItemToFavorites>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionAddItemToFavorites) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionAddItemToFavorites");
static_assert(sizeof(USteamCoreUGCAsyncActionAddItemToFavorites) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionAddItemToFavorites");
static_assert(offsetof(USteamCoreUGCAsyncActionAddItemToFavorites, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionAddItemToFavorites::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionCreateItem
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionCreateItem final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionCreateItem* CreateItemAsync(class UObject* WorldContextObject, int32 ConsumerAppID, ESteamWorkshopFileType FileType, float Timeout);

	void HandleCallback(const struct FCreateItemResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionCreateItem">();
	}
	static class USteamCoreUGCAsyncActionCreateItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionCreateItem>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionCreateItem) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionCreateItem");
static_assert(sizeof(USteamCoreUGCAsyncActionCreateItem) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionCreateItem");
static_assert(offsetof(USteamCoreUGCAsyncActionCreateItem, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionCreateItem::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionRemoveAppDependency
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionRemoveAppDependency final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionRemoveAppDependency* RemoveAppDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, int32 AppID, float Timeout);

	void HandleCallback(const struct FRemoveAppDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionRemoveAppDependency">();
	}
	static class USteamCoreUGCAsyncActionRemoveAppDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionRemoveAppDependency>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionRemoveAppDependency) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionRemoveAppDependency");
static_assert(sizeof(USteamCoreUGCAsyncActionRemoveAppDependency) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionRemoveAppDependency");
static_assert(offsetof(USteamCoreUGCAsyncActionRemoveAppDependency, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionRemoveAppDependency::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionAddUGCDependency
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionAddUGCDependency final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionAddUGCDependency* AddDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId, float Timeout);

	void HandleCallback(const struct FAddUGCDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionAddUGCDependency">();
	}
	static class USteamCoreUGCAsyncActionAddUGCDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionAddUGCDependency>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionAddUGCDependency) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionAddUGCDependency");
static_assert(sizeof(USteamCoreUGCAsyncActionAddUGCDependency) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionAddUGCDependency");
static_assert(offsetof(USteamCoreUGCAsyncActionAddUGCDependency, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionAddUGCDependency::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionRemoveUGCDependency
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionRemoveUGCDependency final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionRemoveUGCDependency* RemoveDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId, float Timeout);

	void HandleCallback(const struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionRemoveUGCDependency">();
	}
	static class USteamCoreUGCAsyncActionRemoveUGCDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionRemoveUGCDependency>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionRemoveUGCDependency) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionRemoveUGCDependency");
static_assert(sizeof(USteamCoreUGCAsyncActionRemoveUGCDependency) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionRemoveUGCDependency");
static_assert(offsetof(USteamCoreUGCAsyncActionRemoveUGCDependency, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionRemoveUGCDependency::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionDeleteItem
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionDeleteItem final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionDeleteItem* DeleteItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FUGCDeleteItemResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionDeleteItem">();
	}
	static class USteamCoreUGCAsyncActionDeleteItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionDeleteItem>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionDeleteItem) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionDeleteItem");
static_assert(sizeof(USteamCoreUGCAsyncActionDeleteItem) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionDeleteItem");
static_assert(offsetof(USteamCoreUGCAsyncActionDeleteItem, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionDeleteItem::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionGetAppDependencies
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionGetAppDependencies final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionGetAppDependencies* GetAppDependenciesAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout);

	void HandleCallback(const struct FGetAppDependenciesResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionGetAppDependencies">();
	}
	static class USteamCoreUGCAsyncActionGetAppDependencies* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionGetAppDependencies>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionGetAppDependencies) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionGetAppDependencies");
static_assert(sizeof(USteamCoreUGCAsyncActionGetAppDependencies) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionGetAppDependencies");
static_assert(offsetof(USteamCoreUGCAsyncActionGetAppDependencies, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionGetAppDependencies::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUGCAsyncActionDownloadItem
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUGCAsyncActionDownloadItem final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUGCAsyncActionDownloadItem* DownloadItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, bool bHighPriority, float Timeout);

	void HandleCallback(const struct FDownloadItemResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUGCAsyncActionDownloadItem">();
	}
	static class USteamCoreUGCAsyncActionDownloadItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUGCAsyncActionDownloadItem>();
	}
};
static_assert(alignof(USteamCoreUGCAsyncActionDownloadItem) == 0x000008, "Wrong alignment on USteamCoreUGCAsyncActionDownloadItem");
static_assert(sizeof(USteamCoreUGCAsyncActionDownloadItem) == 0x000048, "Wrong size on USteamCoreUGCAsyncActionDownloadItem");
static_assert(offsetof(USteamCoreUGCAsyncActionDownloadItem, OnCallback) == 0x000038, "Member 'USteamCoreUGCAsyncActionDownloadItem::OnCallback' has a wrong offset!");

// Class SteamCore.User
// 0x0210 (0x0278 - 0x0068)
class UUser final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             ClientGameServerDeny;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GameWebCallback;                                   // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetAuthSessionTicketResponse;                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             IPCFailure;                                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LicensesUpdated;                                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             MicroTxnAuthorizationResponse;                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamServerConnectFailure;                         // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamServersConnected;                             // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamServersDisconnected;                          // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ValidateAuthTicketResponse;                        // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EncryptedAppTicketResponse;                        // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x160];                                    // 0x0118(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AdvertiseGame(const struct FSteamID& SteamIDGameServer, const class FString& ServerIP, int32 ServerPort);
	static ESteamBeginAuthSessionResult BeginAuthSession(const TArray<uint8>& Ticket, const struct FSteamID& SteamID);
	static bool BIsBehindNAT();
	static bool BIsPhoneIdentifying();
	static bool BIsPhoneRequiringVerification();
	static bool BIsPhoneVerified();
	static bool BIsTwoFactorEnabled();
	static bool BLoggedOn();
	static void CancelAuthTicket(const struct FSteamTicketHandle& TicketHandle);
	static ESteamVoiceResult DecompressVoice(const TArray<uint8>& CompressedBuffer, int32 DesiredSampleRate, TArray<uint8>* DestBuffer);
	static void EndAuthSession(const struct FSteamID& SteamID);
	static struct FSteamTicketHandle GetAuthSessionTicket(TArray<uint8>* Ticket);
	static ESteamVoiceResult GetAvailableVoice(int32* CompressedBytes, int32* UncompressedBytes, int32 UncompressedVoiceDesiredSampleRate);
	static bool GetEncryptedAppTicket(TArray<uint8>* Ticket);
	static int32 GetGameBadgeLevel(int32 Series, bool bFoil);
	static int32 GetPlayerSteamLevel();
	static struct FSteamID GetSteamID();
	static struct FSteamID GetSteamID_Pure();
	static ESteamVoiceResult GetVoice(TArray<uint8>* DestBuffer, int32* BytesWritten);
	static int32 GetVoiceOptimalSampleRate();
	static void StartVoiceRecording();
	static void StopVoiceRecording();
	static ESteamUserHasLicenseForAppResult UserHasLicenseForApp(const struct FSteamID& SteamID, int32 AppID);

	void RequestEncryptedAppTicket(const TDelegate<void(struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful)>& Callback, const TArray<uint8>& DataToInclude);
	void RequestStoreAuthURL(const TDelegate<void(struct FStoreAuthURLResponse& Data, bool bWasSuccessful)>& Callback, const class FString& RedirectURL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"User">();
	}
	static class UUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUser>();
	}
};
static_assert(alignof(UUser) == 0x000008, "Wrong alignment on UUser");
static_assert(sizeof(UUser) == 0x000278, "Wrong size on UUser");
static_assert(offsetof(UUser, ClientGameServerDeny) == 0x000068, "Member 'UUser::ClientGameServerDeny' has a wrong offset!");
static_assert(offsetof(UUser, GameWebCallback) == 0x000078, "Member 'UUser::GameWebCallback' has a wrong offset!");
static_assert(offsetof(UUser, GetAuthSessionTicketResponse) == 0x000088, "Member 'UUser::GetAuthSessionTicketResponse' has a wrong offset!");
static_assert(offsetof(UUser, IPCFailure) == 0x000098, "Member 'UUser::IPCFailure' has a wrong offset!");
static_assert(offsetof(UUser, LicensesUpdated) == 0x0000A8, "Member 'UUser::LicensesUpdated' has a wrong offset!");
static_assert(offsetof(UUser, MicroTxnAuthorizationResponse) == 0x0000B8, "Member 'UUser::MicroTxnAuthorizationResponse' has a wrong offset!");
static_assert(offsetof(UUser, SteamServerConnectFailure) == 0x0000C8, "Member 'UUser::SteamServerConnectFailure' has a wrong offset!");
static_assert(offsetof(UUser, SteamServersConnected) == 0x0000D8, "Member 'UUser::SteamServersConnected' has a wrong offset!");
static_assert(offsetof(UUser, SteamServersDisconnected) == 0x0000E8, "Member 'UUser::SteamServersDisconnected' has a wrong offset!");
static_assert(offsetof(UUser, ValidateAuthTicketResponse) == 0x0000F8, "Member 'UUser::ValidateAuthTicketResponse' has a wrong offset!");
static_assert(offsetof(UUser, EncryptedAppTicketResponse) == 0x000108, "Member 'UUser::EncryptedAppTicketResponse' has a wrong offset!");

// Class SteamCore.SteamCoreUserAsyncActionRequestEncryptedAppTicket
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserAsyncActionRequestEncryptedAppTicket final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserAsyncActionRequestEncryptedAppTicket* RequestEncryptedAppTicketAsync(class UObject* WorldContextObject, const TArray<uint8>& DataToInclude, float Timeout);

	void HandleCallback(const struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserAsyncActionRequestEncryptedAppTicket">();
	}
	static class USteamCoreUserAsyncActionRequestEncryptedAppTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserAsyncActionRequestEncryptedAppTicket>();
	}
};
static_assert(alignof(USteamCoreUserAsyncActionRequestEncryptedAppTicket) == 0x000008, "Wrong alignment on USteamCoreUserAsyncActionRequestEncryptedAppTicket");
static_assert(sizeof(USteamCoreUserAsyncActionRequestEncryptedAppTicket) == 0x000048, "Wrong size on USteamCoreUserAsyncActionRequestEncryptedAppTicket");
static_assert(offsetof(USteamCoreUserAsyncActionRequestEncryptedAppTicket, OnCallback) == 0x000038, "Member 'USteamCoreUserAsyncActionRequestEncryptedAppTicket::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserAsyncActionRequestStoreAuthURL
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserAsyncActionRequestStoreAuthURL final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserAsyncActionRequestStoreAuthURL* RequestStoreAuthURLAsync(class UObject* WorldContextObject, const class FString& RedirectURL, float Timeout);

	void HandleCallback(const struct FStoreAuthURLResponse& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserAsyncActionRequestStoreAuthURL">();
	}
	static class USteamCoreUserAsyncActionRequestStoreAuthURL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserAsyncActionRequestStoreAuthURL>();
	}
};
static_assert(alignof(USteamCoreUserAsyncActionRequestStoreAuthURL) == 0x000008, "Wrong alignment on USteamCoreUserAsyncActionRequestStoreAuthURL");
static_assert(sizeof(USteamCoreUserAsyncActionRequestStoreAuthURL) == 0x000048, "Wrong size on USteamCoreUserAsyncActionRequestStoreAuthURL");
static_assert(offsetof(USteamCoreUserAsyncActionRequestStoreAuthURL, OnCallback) == 0x000038, "Member 'USteamCoreUserAsyncActionRequestStoreAuthURL::OnCallback' has a wrong offset!");

// Class SteamCore.UserStats
// 0x00F0 (0x0158 - 0x0068)
class UUserStats final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             UserAchievementIconFetched;                        // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserAchievementStored;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserStatsReceived;                                 // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserStatsStored;                                   // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UserStatsUnloaded;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0xA0];                                      // 0x00B8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ClearAchievement(const class FString& Name_0);
	static bool GetAchievement(const class FString& Name_0, bool* bAchieved);
	static bool GetAchievementAchievedPercent(const class FString& Name_0, float* Percent);
	static bool GetAchievementAndUnlockTime(const class FString& Name_0, bool* bAchieved, int32* UnlockTime);
	static class FString GetAchievementDisplayAttribute(const class FString& Name_0, const class FString& Key);
	static class UTexture2D* GetAchievementIcon(const class FString& Name_0);
	static class FString GetAchievementName(int32 Achievement);
	static bool GetAchievementProgressLimits(const class FString& Name_0, int32* MinProgress, int32* MaxProgress);
	static bool GetAchievementProgressLimitsFloat(const class FString& Name_0, float* MinProgress, float* MaxProgress);
	static bool GetDownloadedLeaderboardEntry(const struct FSteamLeaderboardEntries& LeaderboardEntries, int32 Index_0, struct FSteamLeaderboardEntry* LeaderboardEntry, const TArray<int32>& Details, TArray<int32>* OutDetails);
	static bool GetGlobalStatFloat(const class FString& StatName, float* Data);
	static int32 GetGlobalStatHistoryFloat(const class FString& StatName, int32 HistoryDays, TArray<float>* Data);
	static int32 GetGlobalStatHistoryInt(const class FString& StatName, int32 HistoryDays, TArray<int32>* Data);
	static bool GetGlobalStatInt(const class FString& StatName, int32* Data);
	static ESteamLeaderboardDisplayType GetLeaderboardDisplayType(const struct FSteamLeaderboard& SteamLeaderboard);
	static int32 GetLeaderboardEntryCount(const struct FSteamLeaderboard& SteamLeaderboard);
	static class FString GetLeaderboardName(const struct FSteamLeaderboard& SteamLeaderboard);
	static ESteamLeaderboardSortMethod GetLeaderboardSortMethod(const struct FSteamLeaderboard& SteamLeaderboard);
	static int32 GetMostAchievedAchievementInfo(class FString* Name_0, float* Percent, bool* bAchieved);
	static int32 GetNextMostAchievedAchievementInfo(int32 IteratorPrevious, class FString* Name_0, float* Percent, bool* bAchieved);
	static int32 GetNumAchievements();
	static bool GetStatFloat(const class FString& Name_0, float* Data);
	static bool GetStatInt(const class FString& Name_0, int32* Data);
	static bool GetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Name_0, bool* bAchieved);
	static bool GetUserAchievementAndUnlockTime(const struct FSteamID& SteamIDUser, const class FString& Name_0, bool* bAchieved, int32* UnlockTime);
	static bool GetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Name_0, float* Data);
	static bool GetUserStatInteger(const struct FSteamID& SteamIDUser, const class FString& Name_0, int32* Data);
	static bool IndicateAchievementProgress(const class FString& Name_0, int32 CurrentProgress, int32 MaxProgress);
	static bool RequestCurrentStats();
	static bool ResetAllStats(bool bAchievementsToo);
	static bool SetAchievement(const class FString& Name_0);
	static bool SetStatFloat(const class FString& Name_0, float Data);
	static bool SetStatInt(const class FString& Name_0, int32 Data);
	static bool StoreStats();
	static bool UpdateAvgRateStat(const class FString& Name_0, float CountThisSession, float SessionLength);

	void AttachLeaderboardUGC(const TDelegate<void(struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, const struct FSteamUGCHandle& Handle);
	void DownloadLeaderboardEntries(const TDelegate<void(struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardDataRequest DataRequest, int32 RangeStart, int32 RangeEnd);
	void DownloadLeaderboardEntriesForUsers(const TDelegate<void(struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, const TArray<struct FSteamID>& Users);
	void FindLeaderboard(const TDelegate<void(struct FLeaderboardFindResult& Data, bool bWasSuccessful)>& Callback, const class FString& LeaderboardName);
	void FindOrCreateLeaderboard(const TDelegate<void(struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful)>& Callback, const class FString& LeaderboardName, ESteamLeaderboardSortMethod SortMethod, ESteamLeaderboardDisplayType DisplayType);
	void GetNumberOfCurrentPlayers(const TDelegate<void(struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful)>& Callback);
	void RequestGlobalAchievementPercentages(const TDelegate<void(struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful)>& Callback);
	void RequestGlobalStats(const TDelegate<void(struct FGlobalStatsReceived& Data, bool bWasSuccessful)>& Callback, int32 HistoryDays);
	void RequestUserStats(const TDelegate<void(struct FRequestUserStatsData& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID);
	void UploadLeaderboardScore(const TDelegate<void(struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardUploadScoreMethod UploadScoreMethod, int32 Score, const TArray<int32>& ScoreDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserStats">();
	}
	static class UUserStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserStats>();
	}
};
static_assert(alignof(UUserStats) == 0x000008, "Wrong alignment on UUserStats");
static_assert(sizeof(UUserStats) == 0x000158, "Wrong size on UUserStats");
static_assert(offsetof(UUserStats, UserAchievementIconFetched) == 0x000068, "Member 'UUserStats::UserAchievementIconFetched' has a wrong offset!");
static_assert(offsetof(UUserStats, UserAchievementStored) == 0x000078, "Member 'UUserStats::UserAchievementStored' has a wrong offset!");
static_assert(offsetof(UUserStats, UserStatsReceived) == 0x000088, "Member 'UUserStats::UserStatsReceived' has a wrong offset!");
static_assert(offsetof(UUserStats, UserStatsStored) == 0x000098, "Member 'UUserStats::UserStatsStored' has a wrong offset!");
static_assert(offsetof(UUserStats, UserStatsUnloaded) == 0x0000A8, "Member 'UUserStats::UserStatsUnloaded' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionFindLeaderboard
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionFindLeaderboard final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionFindLeaderboard* FindLeaderboardAsync(class UObject* WorldContextObject, const class FString& LeaderboardName, float Timeout);

	void HandleCallback(const struct FLeaderboardFindResult& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionFindLeaderboard">();
	}
	static class USteamCoreUserStatsAsyncActionFindLeaderboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionFindLeaderboard>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionFindLeaderboard) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionFindLeaderboard");
static_assert(sizeof(USteamCoreUserStatsAsyncActionFindLeaderboard) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionFindLeaderboard");
static_assert(offsetof(USteamCoreUserStatsAsyncActionFindLeaderboard, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionFindLeaderboard::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionDownloadLeaderboardEntries
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries* DownloadLeaderboardEntriesAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardDataRequest Request, int32 RangeStart, int32 RangeEnd, float Timeout);

	void HandleCallback(const struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionDownloadLeaderboardEntries">();
	}
	static class USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries");
static_assert(sizeof(USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries");
static_assert(offsetof(USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionDownloadLeaderboardEntries::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionDownloadRequestGlobalStats
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats* RequestGlobalStatsAsync(class UObject* WorldContextObject, int32 HistoryDays, float Timeout);

	void HandleCallback(const struct FGlobalStatsReceived& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionDownloadRequestGlobalStats">();
	}
	static class USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats");
static_assert(sizeof(USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats");
static_assert(offsetof(USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionDownloadRequestGlobalStats::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages* RequestGlobalAchievementPercentagesAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages">();
	}
	static class USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages");
static_assert(sizeof(USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages");
static_assert(offsetof(USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionRequestGlobalAchievementPercentages::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers* GetNumberOfCurrentPlayersAsync(class UObject* WorldContextObject, float Timeout);

	void HandleCallback(const struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers">();
	}
	static class USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers");
static_assert(sizeof(USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers");
static_assert(offsetof(USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionGetNumberOfCurrentPlayers::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionUploadLeaderboardScore
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionUploadLeaderboardScore final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionUploadLeaderboardScore* UploadLeaderboardScoreAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardUploadScoreMethod UploadScoreMethod, int32 Score, const TArray<int32>& ScoreDetails, float Timeout);

	void HandleCallback(const struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionUploadLeaderboardScore">();
	}
	static class USteamCoreUserStatsAsyncActionUploadLeaderboardScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionUploadLeaderboardScore>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionUploadLeaderboardScore) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionUploadLeaderboardScore");
static_assert(sizeof(USteamCoreUserStatsAsyncActionUploadLeaderboardScore) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionUploadLeaderboardScore");
static_assert(offsetof(USteamCoreUserStatsAsyncActionUploadLeaderboardScore, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionUploadLeaderboardScore::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionFindOrCreateLeaderboard
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard* FindOrCreateLeaderboardAsync(class UObject* WorldContextObject, const class FString& LeaderboardName, ESteamLeaderboardSortMethod SortMethod, ESteamLeaderboardDisplayType DisplayType, float Timeout);

	void HandleCallback(const struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionFindOrCreateLeaderboard">();
	}
	static class USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard");
static_assert(sizeof(USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard");
static_assert(offsetof(USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionFindOrCreateLeaderboard::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionRequestUserStats
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionRequestUserStats final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionRequestUserStats* RequestUserStatsAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout);

	void HandleCallback(const struct FRequestUserStatsData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionRequestUserStats">();
	}
	static class USteamCoreUserStatsAsyncActionRequestUserStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionRequestUserStats>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionRequestUserStats) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionRequestUserStats");
static_assert(sizeof(USteamCoreUserStatsAsyncActionRequestUserStats) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionRequestUserStats");
static_assert(offsetof(USteamCoreUserStatsAsyncActionRequestUserStats, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionRequestUserStats::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers* DownloadLeaderboardEntriesForUsersAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, const TArray<struct FSteamID>& Users, float Timeout);

	void HandleCallback(const struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers">();
	}
	static class USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers");
static_assert(sizeof(USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers");
static_assert(offsetof(USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionDownloadLeaderboardEntriesForUsers::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreUserStatsAsyncActionAttachLeaderboardUGC
// 0x0010 (0x0048 - 0x0038)
class USteamCoreUserStatsAsyncActionAttachLeaderboardUGC final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnCallback;                                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreUserStatsAsyncActionAttachLeaderboardUGC* AttachLeaderboardUGCAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, const struct FSteamUGCHandle& Handle, float Timeout);

	void HandleCallback(const struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreUserStatsAsyncActionAttachLeaderboardUGC">();
	}
	static class USteamCoreUserStatsAsyncActionAttachLeaderboardUGC* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreUserStatsAsyncActionAttachLeaderboardUGC>();
	}
};
static_assert(alignof(USteamCoreUserStatsAsyncActionAttachLeaderboardUGC) == 0x000008, "Wrong alignment on USteamCoreUserStatsAsyncActionAttachLeaderboardUGC");
static_assert(sizeof(USteamCoreUserStatsAsyncActionAttachLeaderboardUGC) == 0x000048, "Wrong size on USteamCoreUserStatsAsyncActionAttachLeaderboardUGC");
static_assert(offsetof(USteamCoreUserStatsAsyncActionAttachLeaderboardUGC, OnCallback) == 0x000038, "Member 'USteamCoreUserStatsAsyncActionAttachLeaderboardUGC::OnCallback' has a wrong offset!");

// Class SteamCore.SteamCoreVoice
// 0x0000 (0x03C0 - 0x03C0)
class USteamCoreVoice final : public USoundWaveProcedural
{
public:
	static class USteamCoreVoice* ConstructSteamCoreVoice(int32 AudioSampleRate);
	static void DestroySteamCoreVoice(class USteamCoreVoice* Obj);

	void AddAudioBuffer(const TArray<uint8>& Buffer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreVoice">();
	}
	static class USteamCoreVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreVoice>();
	}
};
static_assert(alignof(USteamCoreVoice) == 0x000008, "Wrong alignment on USteamCoreVoice");
static_assert(sizeof(USteamCoreVoice) == 0x0003C0, "Wrong size on USteamCoreVoice");

// Class SteamCore.SteamCoreAsyncActionListenForControllerChange
// 0x0010 (0x0048 - 0x0038)
class USteamCoreAsyncActionListenForControllerChange final : public USteamCoreAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnControllerChanged;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USteamCoreAsyncActionListenForControllerChange* ListenForControllerChange(class UObject* WorldContextObject);

	void HandleCallback(bool bIsConnected, int32 PlatformUserId, int32 UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamCoreAsyncActionListenForControllerChange">();
	}
	static class USteamCoreAsyncActionListenForControllerChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamCoreAsyncActionListenForControllerChange>();
	}
};
static_assert(alignof(USteamCoreAsyncActionListenForControllerChange) == 0x000008, "Wrong alignment on USteamCoreAsyncActionListenForControllerChange");
static_assert(sizeof(USteamCoreAsyncActionListenForControllerChange) == 0x000048, "Wrong size on USteamCoreAsyncActionListenForControllerChange");
static_assert(offsetof(USteamCoreAsyncActionListenForControllerChange, OnControllerChanged) == 0x000038, "Member 'USteamCoreAsyncActionListenForControllerChange::OnControllerChanged' has a wrong offset!");

// Class SteamCore.SteamUtilities
// 0x0000 (0x0028 - 0x0028)
class USteamUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FString BP_BytesToString(const TArray<uint8>& Array);
	static TArray<uint8> BP_StringToBytes(const class FString& String);
	static class FString BreakInventoryUpdateHandle(const struct FSteamInventoryUpdateHandle& Handle);
	static class FString BreakPublishedFileID(const struct FPublishedFileID& FileID);
	static class FString BreakSteamGameID(const struct FSteamGameID& SteamID);
	static class FString BreakSteamID(const struct FSteamID& SteamID);
	static class FString BreakTicketHandle(const struct FSteamTicketHandle& Handle);
	static class FString BreakUGCHandle(const struct FSteamUGCHandle& Handle);
	static class UServerFilter* ConstructServerFilter(class UObject* WorldContextObject);
	static class FString EncryptString(const class FString& String);
	static bool Equal(const struct FSteamID& A, const struct FSteamID& B);
	static void Equal_Exec(const struct FSteamID& A, const struct FSteamID& B, ESteamCoreIdentical* Result);
	static struct FDateTime FromUnixTimestamp(const class FString& Timestamp);
	static ESteamAccountType GetAccountType(const struct FSteamID& SteamID);
	static bool GetBool(const struct FSteamSessionSetting& Settings, class FString* Key, bool* OutValue);
	static bool GetGameEngineInitialized();
	static struct FHostPingData GetHostPingData();
	static bool GetInteger(const struct FSteamSessionSetting& Settings, class FString* Key, int32* OutValue);
	static int32 GetPingFromHostData(const struct FHostPingData& Data);
	static void GetPublicIp(const TDelegate<void(const class FString& Response)>& Callback);
	static struct FSteamID GetSteamIdFromPlayerState(class APlayerState* PlayerState);
	static bool GetString(const struct FSteamSessionSetting& Settings, class FString* Key, class FString* OutValue);
	static ESteamAttributeType GetType(const struct FSteamSessionSetting& Settings);
	static bool IsGameIDValid(const struct FSteamGameID& GameID);
	static void IsGameIDValid_Exec(const struct FSteamGameID& GameID, ESteamCoreValid* Result);
	static bool IsLobby(const struct FSteamID& SteamID);
	static bool IsPublishedFileIDValid(const struct FPublishedFileID& PublishedFileID);
	static void IsPublishedFileIDValid_Exec(const struct FPublishedFileID& Handle, ESteamCoreValid* Result);
	static bool IsRecalculatingPing();
	static bool IsSteamAvailable();
	static void IsSteamIDValid_Exec(const struct FSteamID& SteamID, ESteamCoreValid* Result);
	static bool IsSteamInventoryUpdateHandleValid(const struct FSteamInventoryUpdateHandle& Handle);
	static void IsSteamInventoryUpdateHandleValid_Exec(const struct FSteamInventoryUpdateHandle& Handle, ESteamCoreValid* Result);
	static bool IsSteamServerInitialized();
	static bool IsSteamTicketHandleValid(const struct FSteamTicketHandle& Handle);
	static void IsSteamTicketHandleValid_Exec(const struct FSteamTicketHandle& Handle, ESteamCoreValid* Result);
	static bool IsUGCHandleValid(const struct FSteamUGCHandle& Handle);
	static void IsUGCHandleValid_Exec(const struct FSteamUGCHandle& Handle, ESteamCoreValid* Result);
	static bool IsUsingP2PRelays();
	static bool IsValid(const struct FSteamID& SteamID);
	static TArray<uint8> K2_HexToBytes(const class FString& String);
	static class FString K2_HexToString(const TArray<uint8>& Array);
	static bool K2_IsPlayerInSession(int32 LocalUserNum);
	static void ListenForSteamMessages(const TDelegate<void(ESteamMessageType Type, const class FString& Message)>& Callback);
	static struct FSteamSessionSetting MakeBool(const bool bValue);
	static struct FSteamSessionSetting MakeInteger(const int32 Value);
	static struct FSteamInventoryUpdateHandle MakeInventoryUpdateHandle(const class FString& Value);
	static struct FPublishedFileID MakePublishedFileID(const class FString& Value);
	static struct FSteamSessionSearchSetting MakeSearchBool(const bool bValue);
	static struct FSteamSessionSearchSetting MakeSearchInteger(const ESteamComparisonOp ComparisonOperator, const int32 Value);
	static struct FSteamSessionSearchSetting MakeSearchString(const class FString& Value);
	static struct FSteamGameID MakeSteamGameID(const class FString& Value);
	static struct FSteamID MakeSteamID(const class FString& Value);
	static struct FSteamSessionSetting MakeString(const class FString& Value);
	static struct FSteamTicketHandle MakeTicketHandle(const class FString& Value);
	static struct FSteamUGCHandle MakeUGCHandle(const class FString& Value);
	static bool NotEqual(const struct FSteamID& A, const struct FSteamID& B);
	static bool PublishedFileID_Equals(const struct FPublishedFileID& A, const struct FPublishedFileID& B);
	static void PublishedFileID_Equals_Exec(const struct FPublishedFileID& A, const struct FPublishedFileID& B, ESteamCoreIdentical* Result);
	static bool PublishedFileID_NotEquals(const struct FPublishedFileID& A, const struct FPublishedFileID& B);
	static TArray<uint8> ReadFileToBytes(const class FString& AbsoluteFilePath);
	static bool SteamItemInstanceID_Equals(const struct FSteamItemInstanceID& A, const struct FSteamItemInstanceID& B);
	static void SteamItemInstanceID_Equals_Exec(const struct FSteamItemInstanceID& A, const struct FSteamItemInstanceID& B, ESteamCoreIdentical* Result);
	static bool WriteBytesToFile(bool bOverwriteIfExists, const class FString& AbsoluteFilePath, const TArray<uint8>& DataBuffer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamUtilities">();
	}
	static class USteamUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamUtilities>();
	}
};
static_assert(alignof(USteamUtilities) == 0x000008, "Wrong alignment on USteamUtilities");
static_assert(sizeof(USteamUtilities) == 0x000028, "Wrong size on USteamUtilities");

// Class SteamCore.Utils
// 0x00F0 (0x0158 - 0x0068)
class UUtils final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             CheckFileSignature;                                // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GamepadTextInputDismissed;                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             IPCountry;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             LowBatteryPower;                                   // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SteamShutdown;                                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0xA0];                                      // 0x00B8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool BOverlayNeedsPresent();
	static int32 GetAppID();
	static int32 GetAppID_Pure();
	static ESteamUniverse GetConnectedUniverse();
	static int32 GetCurrentBatteryPower();
	static bool GetEnteredGamepadTextInput(class FString* Text);
	static int32 GetEnteredGamepadTextLength();
	static bool GetImageRGBA(int32 IImage, TArray<uint8>* OutBuffer);
	static bool GetImageSize(int32 IImage, int32* Width, int32* Height);
	static int32 GetIPCCallCount();
	static class FString GetIPCountry();
	static int32 GetSecondsSinceAppActive();
	static int32 GetSecondsSinceComputerActive();
	static int32 GetServerRealTime();
	static class FString GetSteamUILanguage();
	static bool InitFilterText();
	static bool IsOverlayEnabled();
	static bool IsSteamChinaLauncher();
	static bool IsSteamInBigPictureMode();
	static bool IsSteamRunningInVR();
	static bool IsVRHeadsetStreamingEnabled();
	static void SetOverlayNotificationInset(int32 HorizontalInset, int32 VerticalInset);
	static void SetOverlayNotificationPosition(ESteamNotificationPosition NotificationPosition);
	static void SetVRHeadsetStreamingEnabled(bool bEnabled);
	static bool ShowGamepadTextInput(ESteamGamepadTextInputMode InputMode, ESteamGamepadTextInputLineMode LineInputMode, const class FString& Description, int32 CharMax, const class FString& ExistingText);
	static void StartVRDashboard();

	bool IsSteamRunningOnSteamDeck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Utils">();
	}
	static class UUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtils>();
	}
};
static_assert(alignof(UUtils) == 0x000008, "Wrong alignment on UUtils");
static_assert(sizeof(UUtils) == 0x000158, "Wrong size on UUtils");
static_assert(offsetof(UUtils, CheckFileSignature) == 0x000068, "Member 'UUtils::CheckFileSignature' has a wrong offset!");
static_assert(offsetof(UUtils, GamepadTextInputDismissed) == 0x000078, "Member 'UUtils::GamepadTextInputDismissed' has a wrong offset!");
static_assert(offsetof(UUtils, IPCountry) == 0x000088, "Member 'UUtils::IPCountry' has a wrong offset!");
static_assert(offsetof(UUtils, LowBatteryPower) == 0x000098, "Member 'UUtils::LowBatteryPower' has a wrong offset!");
static_assert(offsetof(UUtils, SteamShutdown) == 0x0000A8, "Member 'UUtils::SteamShutdown' has a wrong offset!");

// Class SteamCore.Video
// 0x0060 (0x00C8 - 0x0068)
class UVideo final : public USteamCoreSubsystem
{
public:
	FMulticastInlineDelegateProperty_             GetOPFSettingsResult;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetVideoURLResult;                                 // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x40];                                      // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetOPFSettings(int32 VideoAppID);
	static bool GetOPFStringForApp(int32 VideoAppID, class FString* OutBuffer);
	static void GetVideoURL(int32 VideoAppID);
	static bool IsBroadcasting(int32* NumViewers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Video">();
	}
	static class UVideo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVideo>();
	}
};
static_assert(alignof(UVideo) == 0x000008, "Wrong alignment on UVideo");
static_assert(sizeof(UVideo) == 0x0000C8, "Wrong size on UVideo");
static_assert(offsetof(UVideo, GetOPFSettingsResult) == 0x000068, "Member 'UVideo::GetOPFSettingsResult' has a wrong offset!");
static_assert(offsetof(UVideo, GetVideoURLResult) == 0x000078, "Member 'UVideo::GetVideoURLResult' has a wrong offset!");

}

